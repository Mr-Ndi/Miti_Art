// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package miti_art

import (
	"context"
	"fmt"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"postgresql","activeProvider":"postgresql","url":{"fromEnvVar":"DATABASE_URL","value":""},"config":null}]`

const schema = `generator client {
  provider = "prisma-client-go"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String     @id @default(uuid())
  firstName String
  otherName String
  email     String     @unique
  password  String
  salt      String
  role      String // "admin", "vendor", "customer"
  Vendor    Vendor[]
  Order     Order[]
  Wishlist  Wishlist[]
}

model Vendor {
  id            String    @id @default(uuid())
  user          User      @relation(fields: [userId], references: [id])
  userId        String
  business_name String
  tax_pin       String    @unique
  approved      Boolean   @default(false)
  Product       Product[]
}

model Product {
  id       String     @id @default(uuid())
  vendor   Vendor     @relation(fields: [vendorId], references: [id])
  vendorId String
  name     String
  price    Float
  category String
  imageUrl String
  Order    Order[]
  Wishlist Wishlist[]
}

model Order {
  id        String  @id @default(uuid())
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  product   Product @relation(fields: [productId], references: [id])
  productId String
  quantity  Int
  status    String // "pending", "shipped", "completed"
}

model Wishlist {
  id        String  @id @default(uuid())
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  product   Product @relation(fields: [productId], references: [id])
  productId String
}
`
const schemaDatasourceURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set " + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}
	c.Vendor = vendorActions{client: c}
	c.Product = productActions{client: c}
	c.Order = orderActions{client: c}
	c.Wishlist = wishlistActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
	// Vendor provides access to CRUD methods.
	Vendor vendorActions
	// Product provides access to CRUD methods.
	Product productActions
	// Order provides access to CRUD methods.
	Order orderActions
	// Wishlist provides access to CRUD methods.
	Wishlist wishlistActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID        UserScalarFieldEnum = "id"
	UserScalarFieldEnumFirstName UserScalarFieldEnum = "firstName"
	UserScalarFieldEnumOtherName UserScalarFieldEnum = "otherName"
	UserScalarFieldEnumEmail     UserScalarFieldEnum = "email"
	UserScalarFieldEnumPassword  UserScalarFieldEnum = "password"
	UserScalarFieldEnumSalt      UserScalarFieldEnum = "salt"
	UserScalarFieldEnumRole      UserScalarFieldEnum = "role"
)

type VendorScalarFieldEnum string

const (
	VendorScalarFieldEnumID           VendorScalarFieldEnum = "id"
	VendorScalarFieldEnumUserID       VendorScalarFieldEnum = "userId"
	VendorScalarFieldEnumBusinessName VendorScalarFieldEnum = "business_name"
	VendorScalarFieldEnumTaxPin       VendorScalarFieldEnum = "tax_pin"
	VendorScalarFieldEnumApproved     VendorScalarFieldEnum = "approved"
)

type ProductScalarFieldEnum string

const (
	ProductScalarFieldEnumID       ProductScalarFieldEnum = "id"
	ProductScalarFieldEnumVendorID ProductScalarFieldEnum = "vendorId"
	ProductScalarFieldEnumName     ProductScalarFieldEnum = "name"
	ProductScalarFieldEnumPrice    ProductScalarFieldEnum = "price"
	ProductScalarFieldEnumCategory ProductScalarFieldEnum = "category"
	ProductScalarFieldEnumImageURL ProductScalarFieldEnum = "imageUrl"
)

type OrderScalarFieldEnum string

const (
	OrderScalarFieldEnumID        OrderScalarFieldEnum = "id"
	OrderScalarFieldEnumUserID    OrderScalarFieldEnum = "userId"
	OrderScalarFieldEnumProductID OrderScalarFieldEnum = "productId"
	OrderScalarFieldEnumQuantity  OrderScalarFieldEnum = "quantity"
	OrderScalarFieldEnumStatus    OrderScalarFieldEnum = "status"
)

type WishlistScalarFieldEnum string

const (
	WishlistScalarFieldEnumID        WishlistScalarFieldEnum = "id"
	WishlistScalarFieldEnumUserID    WishlistScalarFieldEnum = "userId"
	WishlistScalarFieldEnumProductID WishlistScalarFieldEnum = "productId"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type userPrismaFields = prismaFields

const userFieldID userPrismaFields = "id"

const userFieldFirstName userPrismaFields = "firstName"

const userFieldOtherName userPrismaFields = "otherName"

const userFieldEmail userPrismaFields = "email"

const userFieldPassword userPrismaFields = "password"

const userFieldSalt userPrismaFields = "salt"

const userFieldRole userPrismaFields = "role"

const userFieldVendor userPrismaFields = "Vendor"

const userFieldOrder userPrismaFields = "Order"

const userFieldWishlist userPrismaFields = "Wishlist"

type vendorPrismaFields = prismaFields

const vendorFieldID vendorPrismaFields = "id"

const vendorFieldUser vendorPrismaFields = "user"

const vendorFieldUserID vendorPrismaFields = "userId"

const vendorFieldBusinessName vendorPrismaFields = "business_name"

const vendorFieldTaxPin vendorPrismaFields = "tax_pin"

const vendorFieldApproved vendorPrismaFields = "approved"

const vendorFieldProduct vendorPrismaFields = "Product"

type productPrismaFields = prismaFields

const productFieldID productPrismaFields = "id"

const productFieldVendor productPrismaFields = "vendor"

const productFieldVendorID productPrismaFields = "vendorId"

const productFieldName productPrismaFields = "name"

const productFieldPrice productPrismaFields = "price"

const productFieldCategory productPrismaFields = "category"

const productFieldImageURL productPrismaFields = "imageUrl"

const productFieldOrder productPrismaFields = "Order"

const productFieldWishlist productPrismaFields = "Wishlist"

type orderPrismaFields = prismaFields

const orderFieldID orderPrismaFields = "id"

const orderFieldUser orderPrismaFields = "user"

const orderFieldUserID orderPrismaFields = "userId"

const orderFieldProduct orderPrismaFields = "product"

const orderFieldProductID orderPrismaFields = "productId"

const orderFieldQuantity orderPrismaFields = "quantity"

const orderFieldStatus orderPrismaFields = "status"

type wishlistPrismaFields = prismaFields

const wishlistFieldID wishlistPrismaFields = "id"

const wishlistFieldUser wishlistPrismaFields = "user"

const wishlistFieldUserID wishlistPrismaFields = "userId"

const wishlistFieldProduct wishlistPrismaFields = "product"

const wishlistFieldProductID wishlistPrismaFields = "productId"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	m.Vendor = vendorMock{
		mock: m,
	}

	m.Product = productMock{
		mock: m,
	}

	m.Order = orderMock{
		mock: m,
	}

	m.Wishlist = wishlistMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock

	Vendor vendorMock

	Product productMock

	Order orderMock

	Wishlist wishlistMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type vendorMock struct {
	mock *Mock
}

type VendorMockExpectParam interface {
	ExtractQuery() builder.Query
	vendorModel()
}

func (m *vendorMock) Expect(query VendorMockExpectParam) *vendorMockExec {
	return &vendorMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type vendorMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *vendorMockExec) Returns(v VendorModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *vendorMockExec) ReturnsMany(v []VendorModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *vendorMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type productMock struct {
	mock *Mock
}

type ProductMockExpectParam interface {
	ExtractQuery() builder.Query
	productModel()
}

func (m *productMock) Expect(query ProductMockExpectParam) *productMockExec {
	return &productMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type productMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *productMockExec) Returns(v ProductModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *productMockExec) ReturnsMany(v []ProductModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *productMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type orderMock struct {
	mock *Mock
}

type OrderMockExpectParam interface {
	ExtractQuery() builder.Query
	orderModel()
}

func (m *orderMock) Expect(query OrderMockExpectParam) *orderMockExec {
	return &orderMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type orderMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *orderMockExec) Returns(v OrderModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orderMockExec) ReturnsMany(v []OrderModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orderMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type wishlistMock struct {
	mock *Mock
}

type WishlistMockExpectParam interface {
	ExtractQuery() builder.Query
	wishlistModel()
}

func (m *wishlistMock) Expect(query WishlistMockExpectParam) *wishlistMockExec {
	return &wishlistMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type wishlistMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *wishlistMockExec) Returns(v WishlistModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *wishlistMockExec) ReturnsMany(v []WishlistModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *wishlistMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID        string `json:"id"`
	FirstName string `json:"firstName"`
	OtherName string `json:"otherName"`
	Email     string `json:"email"`
	Password  string `json:"password"`
	Salt      string `json:"salt"`
	Role      string `json:"role"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	ID        RawString `json:"id"`
	FirstName RawString `json:"firstName"`
	OtherName RawString `json:"otherName"`
	Email     RawString `json:"email"`
	Password  RawString `json:"password"`
	Salt      RawString `json:"salt"`
	Role      RawString `json:"role"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
	Vendor   []VendorModel   `json:"Vendor,omitempty"`
	Order    []OrderModel    `json:"Order,omitempty"`
	Wishlist []WishlistModel `json:"Wishlist,omitempty"`
}

func (r UserModel) Vendor() (value []VendorModel) {
	if r.RelationsUser.Vendor == nil {
		panic("attempted to access vendor but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Vendor
}

func (r UserModel) Order() (value []OrderModel) {
	if r.RelationsUser.Order == nil {
		panic("attempted to access order but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Order
}

func (r UserModel) Wishlist() (value []WishlistModel) {
	if r.RelationsUser.Wishlist == nil {
		panic("attempted to access wishlist but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Wishlist
}

// VendorModel represents the Vendor model and is a wrapper for accessing fields and methods
type VendorModel struct {
	InnerVendor
	RelationsVendor
}

// InnerVendor holds the actual data
type InnerVendor struct {
	ID           string `json:"id"`
	UserID       string `json:"userId"`
	BusinessName string `json:"business_name"`
	TaxPin       string `json:"tax_pin"`
	Approved     bool   `json:"approved"`
}

// RawVendorModel is a struct for Vendor when used in raw queries
type RawVendorModel struct {
	ID           RawString  `json:"id"`
	UserID       RawString  `json:"userId"`
	BusinessName RawString  `json:"business_name"`
	TaxPin       RawString  `json:"tax_pin"`
	Approved     RawBoolean `json:"approved"`
}

// RelationsVendor holds the relation data separately
type RelationsVendor struct {
	User    *UserModel     `json:"user,omitempty"`
	Product []ProductModel `json:"Product,omitempty"`
}

func (r VendorModel) User() (value *UserModel) {
	if r.RelationsVendor.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsVendor.User
}

func (r VendorModel) Product() (value []ProductModel) {
	if r.RelationsVendor.Product == nil {
		panic("attempted to access product but did not fetch it using the .With() syntax")
	}
	return r.RelationsVendor.Product
}

// ProductModel represents the Product model and is a wrapper for accessing fields and methods
type ProductModel struct {
	InnerProduct
	RelationsProduct
}

// InnerProduct holds the actual data
type InnerProduct struct {
	ID       string  `json:"id"`
	VendorID string  `json:"vendorId"`
	Name     string  `json:"name"`
	Price    float64 `json:"price"`
	Category string  `json:"category"`
	ImageURL string  `json:"imageUrl"`
}

// RawProductModel is a struct for Product when used in raw queries
type RawProductModel struct {
	ID       RawString `json:"id"`
	VendorID RawString `json:"vendorId"`
	Name     RawString `json:"name"`
	Price    RawFloat  `json:"price"`
	Category RawString `json:"category"`
	ImageURL RawString `json:"imageUrl"`
}

// RelationsProduct holds the relation data separately
type RelationsProduct struct {
	Vendor   *VendorModel    `json:"vendor,omitempty"`
	Order    []OrderModel    `json:"Order,omitempty"`
	Wishlist []WishlistModel `json:"Wishlist,omitempty"`
}

func (r ProductModel) Vendor() (value *VendorModel) {
	if r.RelationsProduct.Vendor == nil {
		panic("attempted to access vendor but did not fetch it using the .With() syntax")
	}
	return r.RelationsProduct.Vendor
}

func (r ProductModel) Order() (value []OrderModel) {
	if r.RelationsProduct.Order == nil {
		panic("attempted to access order but did not fetch it using the .With() syntax")
	}
	return r.RelationsProduct.Order
}

func (r ProductModel) Wishlist() (value []WishlistModel) {
	if r.RelationsProduct.Wishlist == nil {
		panic("attempted to access wishlist but did not fetch it using the .With() syntax")
	}
	return r.RelationsProduct.Wishlist
}

// OrderModel represents the Order model and is a wrapper for accessing fields and methods
type OrderModel struct {
	InnerOrder
	RelationsOrder
}

// InnerOrder holds the actual data
type InnerOrder struct {
	ID        string `json:"id"`
	UserID    string `json:"userId"`
	ProductID string `json:"productId"`
	Quantity  int    `json:"quantity"`
	Status    string `json:"status"`
}

// RawOrderModel is a struct for Order when used in raw queries
type RawOrderModel struct {
	ID        RawString `json:"id"`
	UserID    RawString `json:"userId"`
	ProductID RawString `json:"productId"`
	Quantity  RawInt    `json:"quantity"`
	Status    RawString `json:"status"`
}

// RelationsOrder holds the relation data separately
type RelationsOrder struct {
	User    *UserModel    `json:"user,omitempty"`
	Product *ProductModel `json:"product,omitempty"`
}

func (r OrderModel) User() (value *UserModel) {
	if r.RelationsOrder.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrder.User
}

func (r OrderModel) Product() (value *ProductModel) {
	if r.RelationsOrder.Product == nil {
		panic("attempted to access product but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrder.Product
}

// WishlistModel represents the Wishlist model and is a wrapper for accessing fields and methods
type WishlistModel struct {
	InnerWishlist
	RelationsWishlist
}

// InnerWishlist holds the actual data
type InnerWishlist struct {
	ID        string `json:"id"`
	UserID    string `json:"userId"`
	ProductID string `json:"productId"`
}

// RawWishlistModel is a struct for Wishlist when used in raw queries
type RawWishlistModel struct {
	ID        RawString `json:"id"`
	UserID    RawString `json:"userId"`
	ProductID RawString `json:"productId"`
}

// RelationsWishlist holds the relation data separately
type RelationsWishlist struct {
	User    *UserModel    `json:"user,omitempty"`
	Product *ProductModel `json:"product,omitempty"`
}

func (r WishlistModel) User() (value *UserModel) {
	if r.RelationsWishlist.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsWishlist.User
}

func (r WishlistModel) Product() (value *ProductModel) {
	if r.RelationsWishlist.Product == nil {
		panic("attempted to access product but did not fetch it using the .With() syntax")
	}
	return r.RelationsWishlist.Product
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDString

	// FirstName
	//
	// @required
	FirstName userQueryFirstNameString

	// OtherName
	//
	// @required
	OtherName userQueryOtherNameString

	// Email
	//
	// @required
	// @unique
	Email userQueryEmailString

	// Password
	//
	// @required
	Password userQueryPasswordString

	// Salt
	//
	// @required
	Salt userQuerySaltString

	// Role
	//
	// @required
	Role userQueryRoleString

	Vendor userQueryVendorRelations

	Order userQueryOrderRelations

	Wishlist userQueryWishlistRelations
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIDString) Equals(value string) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EqualsIfPresent(value *string) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryIDString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryIDString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryIDString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryIDString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryIDString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryIDString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryIDString) Field() userPrismaFields {
	return userFieldID
}

// base struct
type userQueryFirstNameString struct{}

// Set the required value of FirstName
func (r userQueryFirstNameString) Set(value string) userWithPrismaFirstNameSetParam {

	return userWithPrismaFirstNameSetParam{
		data: builder.Field{
			Name:  "firstName",
			Value: value,
		},
	}

}

// Set the optional value of FirstName dynamically
func (r userQueryFirstNameString) SetIfPresent(value *String) userWithPrismaFirstNameSetParam {
	if value == nil {
		return userWithPrismaFirstNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryFirstNameString) Equals(value string) userWithPrismaFirstNameEqualsParam {

	return userWithPrismaFirstNameEqualsParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EqualsIfPresent(value *string) userWithPrismaFirstNameEqualsParam {
	if value == nil {
		return userWithPrismaFirstNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryFirstNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "firstName",
			Value: direction,
		},
	}
}

func (r userQueryFirstNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "firstName",
			Value: cursor,
		},
	}
}

func (r userQueryFirstNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryFirstNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryFirstNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryFirstNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryFirstNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryFirstNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryFirstNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryFirstNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryFirstNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryFirstNameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryFirstNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryFirstNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryFirstNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryFirstNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryFirstNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryFirstNameString) Field() userPrismaFields {
	return userFieldFirstName
}

// base struct
type userQueryOtherNameString struct{}

// Set the required value of OtherName
func (r userQueryOtherNameString) Set(value string) userWithPrismaOtherNameSetParam {

	return userWithPrismaOtherNameSetParam{
		data: builder.Field{
			Name:  "otherName",
			Value: value,
		},
	}

}

// Set the optional value of OtherName dynamically
func (r userQueryOtherNameString) SetIfPresent(value *String) userWithPrismaOtherNameSetParam {
	if value == nil {
		return userWithPrismaOtherNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryOtherNameString) Equals(value string) userWithPrismaOtherNameEqualsParam {

	return userWithPrismaOtherNameEqualsParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) EqualsIfPresent(value *string) userWithPrismaOtherNameEqualsParam {
	if value == nil {
		return userWithPrismaOtherNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryOtherNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "otherName",
			Value: direction,
		},
	}
}

func (r userQueryOtherNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "otherName",
			Value: cursor,
		},
	}
}

func (r userQueryOtherNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryOtherNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryOtherNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryOtherNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryOtherNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryOtherNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryOtherNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryOtherNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryOtherNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryOtherNameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryOtherNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryOtherNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryOtherNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryOtherNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryOtherNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "otherName",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryOtherNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryOtherNameString) Field() userPrismaFields {
	return userFieldOtherName
}

// base struct
type userQueryEmailString struct{}

// Set the required value of Email
func (r userQueryEmailString) Set(value string) userWithPrismaEmailSetParam {

	return userWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r userQueryEmailString) SetIfPresent(value *String) userWithPrismaEmailSetParam {
	if value == nil {
		return userWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryEmailString) Equals(value string) userWithPrismaEmailEqualsUniqueParam {

	return userWithPrismaEmailEqualsUniqueParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EqualsIfPresent(value *string) userWithPrismaEmailEqualsUniqueParam {
	if value == nil {
		return userWithPrismaEmailEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryEmailString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userQueryEmailString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userQueryEmailString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryEmailString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryEmailString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryEmailString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryEmailString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryEmailString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryEmailString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryEmailString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryEmailString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryEmailString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryEmailString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryEmailString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryEmailString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryEmailString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryEmailString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryEmailString) Field() userPrismaFields {
	return userFieldEmail
}

// base struct
type userQueryPasswordString struct{}

// Set the required value of Password
func (r userQueryPasswordString) Set(value string) userWithPrismaPasswordSetParam {

	return userWithPrismaPasswordSetParam{
		data: builder.Field{
			Name:  "password",
			Value: value,
		},
	}

}

// Set the optional value of Password dynamically
func (r userQueryPasswordString) SetIfPresent(value *String) userWithPrismaPasswordSetParam {
	if value == nil {
		return userWithPrismaPasswordSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryPasswordString) Equals(value string) userWithPrismaPasswordEqualsParam {

	return userWithPrismaPasswordEqualsParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EqualsIfPresent(value *string) userWithPrismaPasswordEqualsParam {
	if value == nil {
		return userWithPrismaPasswordEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryPasswordString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "password",
			Value: direction,
		},
	}
}

func (r userQueryPasswordString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "password",
			Value: cursor,
		},
	}
}

func (r userQueryPasswordString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryPasswordString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryPasswordString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryPasswordString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryPasswordString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryPasswordString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryPasswordString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryPasswordString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryPasswordString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryPasswordString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryPasswordString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryPasswordString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryPasswordString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryPasswordString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryPasswordString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryPasswordString) Field() userPrismaFields {
	return userFieldPassword
}

// base struct
type userQuerySaltString struct{}

// Set the required value of Salt
func (r userQuerySaltString) Set(value string) userWithPrismaSaltSetParam {

	return userWithPrismaSaltSetParam{
		data: builder.Field{
			Name:  "salt",
			Value: value,
		},
	}

}

// Set the optional value of Salt dynamically
func (r userQuerySaltString) SetIfPresent(value *String) userWithPrismaSaltSetParam {
	if value == nil {
		return userWithPrismaSaltSetParam{}
	}

	return r.Set(*value)
}

func (r userQuerySaltString) Equals(value string) userWithPrismaSaltEqualsParam {

	return userWithPrismaSaltEqualsParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) EqualsIfPresent(value *string) userWithPrismaSaltEqualsParam {
	if value == nil {
		return userWithPrismaSaltEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQuerySaltString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "salt",
			Value: direction,
		},
	}
}

func (r userQuerySaltString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "salt",
			Value: cursor,
		},
	}
}

func (r userQuerySaltString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQuerySaltString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQuerySaltString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQuerySaltString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQuerySaltString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQuerySaltString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQuerySaltString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQuerySaltString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQuerySaltString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQuerySaltString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQuerySaltString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySaltString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQuerySaltString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQuerySaltString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQuerySaltString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "salt",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQuerySaltString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQuerySaltString) Field() userPrismaFields {
	return userFieldSalt
}

// base struct
type userQueryRoleString struct{}

// Set the required value of Role
func (r userQueryRoleString) Set(value string) userWithPrismaRoleSetParam {

	return userWithPrismaRoleSetParam{
		data: builder.Field{
			Name:  "role",
			Value: value,
		},
	}

}

// Set the optional value of Role dynamically
func (r userQueryRoleString) SetIfPresent(value *String) userWithPrismaRoleSetParam {
	if value == nil {
		return userWithPrismaRoleSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryRoleString) Equals(value string) userWithPrismaRoleEqualsParam {

	return userWithPrismaRoleEqualsParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) EqualsIfPresent(value *string) userWithPrismaRoleEqualsParam {
	if value == nil {
		return userWithPrismaRoleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryRoleString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "role",
			Value: direction,
		},
	}
}

func (r userQueryRoleString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "role",
			Value: cursor,
		},
	}
}

func (r userQueryRoleString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryRoleString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryRoleString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryRoleString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryRoleString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryRoleString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryRoleString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryRoleString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryRoleString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryRoleString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryRoleString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryRoleString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryRoleString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryRoleString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryRoleString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryRoleString) Field() userPrismaFields {
	return userFieldRole
}

// base struct
type userQueryVendorVendor struct{}

type userQueryVendorRelations struct{}

// User -> Vendor
//
// @relation
// @required
func (userQueryVendorRelations) Some(
	params ...VendorWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Vendor",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Vendor
//
// @relation
// @required
func (userQueryVendorRelations) Every(
	params ...VendorWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Vendor",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Vendor
//
// @relation
// @required
func (userQueryVendorRelations) None(
	params ...VendorWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Vendor",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryVendorRelations) Fetch(

	params ...VendorWhereParam,

) userToVendorFindMany {
	var v userToVendorFindMany

	v.query.Operation = "query"
	v.query.Method = "Vendor"
	v.query.Outputs = vendorOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryVendorRelations) Link(
	params ...VendorWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "Vendor",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryVendorRelations) Unlink(
	params ...VendorWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "Vendor",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryVendorVendor) Field() userPrismaFields {
	return userFieldVendor
}

// base struct
type userQueryOrderOrder struct{}

type userQueryOrderRelations struct{}

// User -> Order
//
// @relation
// @required
func (userQueryOrderRelations) Some(
	params ...OrderWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Order
//
// @relation
// @required
func (userQueryOrderRelations) Every(
	params ...OrderWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Order
//
// @relation
// @required
func (userQueryOrderRelations) None(
	params ...OrderWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryOrderRelations) Fetch(

	params ...OrderWhereParam,

) userToOrderFindMany {
	var v userToOrderFindMany

	v.query.Operation = "query"
	v.query.Method = "Order"
	v.query.Outputs = orderOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryOrderRelations) Link(
	params ...OrderWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryOrderRelations) Unlink(
	params ...OrderWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryOrderOrder) Field() userPrismaFields {
	return userFieldOrder
}

// base struct
type userQueryWishlistWishlist struct{}

type userQueryWishlistRelations struct{}

// User -> Wishlist
//
// @relation
// @required
func (userQueryWishlistRelations) Some(
	params ...WishlistWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Wishlist
//
// @relation
// @required
func (userQueryWishlistRelations) Every(
	params ...WishlistWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Wishlist
//
// @relation
// @required
func (userQueryWishlistRelations) None(
	params ...WishlistWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryWishlistRelations) Fetch(

	params ...WishlistWhereParam,

) userToWishlistFindMany {
	var v userToWishlistFindMany

	v.query.Operation = "query"
	v.query.Method = "Wishlist"
	v.query.Outputs = wishlistOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryWishlistRelations) Link(
	params ...WishlistWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryWishlistRelations) Unlink(
	params ...WishlistWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryWishlistWishlist) Field() userPrismaFields {
	return userFieldWishlist
}

// Vendor acts as a namespaces to access query methods for the Vendor model
var Vendor = vendorQuery{}

// vendorQuery exposes query functions for the vendor model
type vendorQuery struct {

	// ID
	//
	// @required
	ID vendorQueryIDString

	User vendorQueryUserRelations

	// UserID
	//
	// @required
	UserID vendorQueryUserIDString

	// BusinessName
	//
	// @required
	BusinessName vendorQueryBusinessNameString

	// TaxPin
	//
	// @required
	// @unique
	TaxPin vendorQueryTaxPinString

	// Approved
	//
	// @required
	Approved vendorQueryApprovedBoolean

	Product vendorQueryProductRelations
}

func (vendorQuery) Not(params ...VendorWhereParam) vendorDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (vendorQuery) Or(params ...VendorWhereParam) vendorDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (vendorQuery) And(params ...VendorWhereParam) vendorDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type vendorQueryIDString struct{}

// Set the required value of ID
func (r vendorQueryIDString) Set(value string) vendorSetParam {

	return vendorSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r vendorQueryIDString) SetIfPresent(value *String) vendorSetParam {
	if value == nil {
		return vendorSetParam{}
	}

	return r.Set(*value)
}

func (r vendorQueryIDString) Equals(value string) vendorWithPrismaIDEqualsUniqueParam {

	return vendorWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) EqualsIfPresent(value *string) vendorWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return vendorWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r vendorQueryIDString) Order(direction SortOrder) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r vendorQueryIDString) Cursor(cursor string) vendorCursorParam {
	return vendorCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r vendorQueryIDString) In(value []string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) InIfPresent(value []string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.In(value)
}

func (r vendorQueryIDString) NotIn(value []string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) NotInIfPresent(value []string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.NotIn(value)
}

func (r vendorQueryIDString) Lt(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) LtIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Lt(*value)
}

func (r vendorQueryIDString) Lte(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) LteIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Lte(*value)
}

func (r vendorQueryIDString) Gt(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) GtIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Gt(*value)
}

func (r vendorQueryIDString) Gte(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) GteIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Gte(*value)
}

func (r vendorQueryIDString) Contains(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) ContainsIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Contains(*value)
}

func (r vendorQueryIDString) StartsWith(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) StartsWithIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r vendorQueryIDString) EndsWith(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) EndsWithIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r vendorQueryIDString) Mode(value QueryMode) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) ModeIfPresent(value *QueryMode) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Mode(*value)
}

func (r vendorQueryIDString) Not(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryIDString) NotIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r vendorQueryIDString) HasPrefix(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r vendorQueryIDString) HasPrefixIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r vendorQueryIDString) HasSuffix(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r vendorQueryIDString) HasSuffixIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r vendorQueryIDString) Field() vendorPrismaFields {
	return vendorFieldID
}

// base struct
type vendorQueryUserUser struct{}

type vendorQueryUserRelations struct{}

// Vendor -> User
//
// @relation
// @required
func (vendorQueryUserRelations) Where(
	params ...UserWhereParam,
) vendorDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (vendorQueryUserRelations) Fetch() vendorToUserFindUnique {
	var v vendorToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r vendorQueryUserRelations) Link(
	params UserWhereParam,
) vendorWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return vendorWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return vendorWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r vendorQueryUserRelations) Unlink() vendorWithPrismaUserSetParam {
	var v vendorWithPrismaUserSetParam

	v = vendorWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r vendorQueryUserUser) Field() vendorPrismaFields {
	return vendorFieldUser
}

// base struct
type vendorQueryUserIDString struct{}

// Set the required value of UserID
func (r vendorQueryUserIDString) Set(value string) vendorSetParam {

	return vendorSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r vendorQueryUserIDString) SetIfPresent(value *String) vendorSetParam {
	if value == nil {
		return vendorSetParam{}
	}

	return r.Set(*value)
}

func (r vendorQueryUserIDString) Equals(value string) vendorWithPrismaUserIDEqualsParam {

	return vendorWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) EqualsIfPresent(value *string) vendorWithPrismaUserIDEqualsParam {
	if value == nil {
		return vendorWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r vendorQueryUserIDString) Order(direction SortOrder) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r vendorQueryUserIDString) Cursor(cursor string) vendorCursorParam {
	return vendorCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r vendorQueryUserIDString) In(value []string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) InIfPresent(value []string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.In(value)
}

func (r vendorQueryUserIDString) NotIn(value []string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) NotInIfPresent(value []string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.NotIn(value)
}

func (r vendorQueryUserIDString) Lt(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) LtIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Lt(*value)
}

func (r vendorQueryUserIDString) Lte(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) LteIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Lte(*value)
}

func (r vendorQueryUserIDString) Gt(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) GtIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Gt(*value)
}

func (r vendorQueryUserIDString) Gte(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) GteIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Gte(*value)
}

func (r vendorQueryUserIDString) Contains(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) ContainsIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Contains(*value)
}

func (r vendorQueryUserIDString) StartsWith(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) StartsWithIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r vendorQueryUserIDString) EndsWith(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) EndsWithIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r vendorQueryUserIDString) Mode(value QueryMode) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) ModeIfPresent(value *QueryMode) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Mode(*value)
}

func (r vendorQueryUserIDString) Not(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryUserIDString) NotIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r vendorQueryUserIDString) HasPrefix(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r vendorQueryUserIDString) HasPrefixIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r vendorQueryUserIDString) HasSuffix(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r vendorQueryUserIDString) HasSuffixIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r vendorQueryUserIDString) Field() vendorPrismaFields {
	return vendorFieldUserID
}

// base struct
type vendorQueryBusinessNameString struct{}

// Set the required value of BusinessName
func (r vendorQueryBusinessNameString) Set(value string) vendorWithPrismaBusinessNameSetParam {

	return vendorWithPrismaBusinessNameSetParam{
		data: builder.Field{
			Name:  "business_name",
			Value: value,
		},
	}

}

// Set the optional value of BusinessName dynamically
func (r vendorQueryBusinessNameString) SetIfPresent(value *String) vendorWithPrismaBusinessNameSetParam {
	if value == nil {
		return vendorWithPrismaBusinessNameSetParam{}
	}

	return r.Set(*value)
}

func (r vendorQueryBusinessNameString) Equals(value string) vendorWithPrismaBusinessNameEqualsParam {

	return vendorWithPrismaBusinessNameEqualsParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) EqualsIfPresent(value *string) vendorWithPrismaBusinessNameEqualsParam {
	if value == nil {
		return vendorWithPrismaBusinessNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r vendorQueryBusinessNameString) Order(direction SortOrder) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name:  "business_name",
			Value: direction,
		},
	}
}

func (r vendorQueryBusinessNameString) Cursor(cursor string) vendorCursorParam {
	return vendorCursorParam{
		data: builder.Field{
			Name:  "business_name",
			Value: cursor,
		},
	}
}

func (r vendorQueryBusinessNameString) In(value []string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) InIfPresent(value []string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.In(value)
}

func (r vendorQueryBusinessNameString) NotIn(value []string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) NotInIfPresent(value []string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.NotIn(value)
}

func (r vendorQueryBusinessNameString) Lt(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) LtIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Lt(*value)
}

func (r vendorQueryBusinessNameString) Lte(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) LteIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Lte(*value)
}

func (r vendorQueryBusinessNameString) Gt(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) GtIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Gt(*value)
}

func (r vendorQueryBusinessNameString) Gte(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) GteIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Gte(*value)
}

func (r vendorQueryBusinessNameString) Contains(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) ContainsIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Contains(*value)
}

func (r vendorQueryBusinessNameString) StartsWith(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) StartsWithIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r vendorQueryBusinessNameString) EndsWith(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) EndsWithIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r vendorQueryBusinessNameString) Mode(value QueryMode) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) ModeIfPresent(value *QueryMode) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Mode(*value)
}

func (r vendorQueryBusinessNameString) Not(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryBusinessNameString) NotIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r vendorQueryBusinessNameString) HasPrefix(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r vendorQueryBusinessNameString) HasPrefixIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r vendorQueryBusinessNameString) HasSuffix(value string) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name: "business_name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r vendorQueryBusinessNameString) HasSuffixIfPresent(value *string) vendorDefaultParam {
	if value == nil {
		return vendorDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r vendorQueryBusinessNameString) Field() vendorPrismaFields {
	return vendorFieldBusinessName
}

// base struct
type vendorQueryTaxPinString struct{}

// Set the required value of TaxPin
func (r vendorQueryTaxPinString) Set(value string) vendorWithPrismaTaxPinSetParam {

	return vendorWithPrismaTaxPinSetParam{
		data: builder.Field{
			Name:  "tax_pin",
			Value: value,
		},
	}

}

// Set the optional value of TaxPin dynamically
func (r vendorQueryTaxPinString) SetIfPresent(value *String) vendorWithPrismaTaxPinSetParam {
	if value == nil {
		return vendorWithPrismaTaxPinSetParam{}
	}

	return r.Set(*value)
}

func (r vendorQueryTaxPinString) Equals(value string) vendorWithPrismaTaxPinEqualsUniqueParam {

	return vendorWithPrismaTaxPinEqualsUniqueParam{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) EqualsIfPresent(value *string) vendorWithPrismaTaxPinEqualsUniqueParam {
	if value == nil {
		return vendorWithPrismaTaxPinEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r vendorQueryTaxPinString) Order(direction SortOrder) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name:  "tax_pin",
			Value: direction,
		},
	}
}

func (r vendorQueryTaxPinString) Cursor(cursor string) vendorCursorParam {
	return vendorCursorParam{
		data: builder.Field{
			Name:  "tax_pin",
			Value: cursor,
		},
	}
}

func (r vendorQueryTaxPinString) In(value []string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) InIfPresent(value []string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.In(value)
}

func (r vendorQueryTaxPinString) NotIn(value []string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) NotInIfPresent(value []string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.NotIn(value)
}

func (r vendorQueryTaxPinString) Lt(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) LtIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Lt(*value)
}

func (r vendorQueryTaxPinString) Lte(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) LteIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Lte(*value)
}

func (r vendorQueryTaxPinString) Gt(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) GtIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Gt(*value)
}

func (r vendorQueryTaxPinString) Gte(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) GteIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Gte(*value)
}

func (r vendorQueryTaxPinString) Contains(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) ContainsIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Contains(*value)
}

func (r vendorQueryTaxPinString) StartsWith(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) StartsWithIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r vendorQueryTaxPinString) EndsWith(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) EndsWithIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r vendorQueryTaxPinString) Mode(value QueryMode) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) ModeIfPresent(value *QueryMode) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Mode(*value)
}

func (r vendorQueryTaxPinString) Not(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryTaxPinString) NotIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r vendorQueryTaxPinString) HasPrefix(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r vendorQueryTaxPinString) HasPrefixIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r vendorQueryTaxPinString) HasSuffix(value string) vendorParamUnique {
	return vendorParamUnique{
		data: builder.Field{
			Name: "tax_pin",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r vendorQueryTaxPinString) HasSuffixIfPresent(value *string) vendorParamUnique {
	if value == nil {
		return vendorParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r vendorQueryTaxPinString) Field() vendorPrismaFields {
	return vendorFieldTaxPin
}

// base struct
type vendorQueryApprovedBoolean struct{}

// Set the required value of Approved
func (r vendorQueryApprovedBoolean) Set(value bool) vendorSetParam {

	return vendorSetParam{
		data: builder.Field{
			Name:  "approved",
			Value: value,
		},
	}

}

// Set the optional value of Approved dynamically
func (r vendorQueryApprovedBoolean) SetIfPresent(value *Boolean) vendorSetParam {
	if value == nil {
		return vendorSetParam{}
	}

	return r.Set(*value)
}

func (r vendorQueryApprovedBoolean) Equals(value bool) vendorWithPrismaApprovedEqualsParam {

	return vendorWithPrismaApprovedEqualsParam{
		data: builder.Field{
			Name: "approved",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r vendorQueryApprovedBoolean) EqualsIfPresent(value *bool) vendorWithPrismaApprovedEqualsParam {
	if value == nil {
		return vendorWithPrismaApprovedEqualsParam{}
	}
	return r.Equals(*value)
}

func (r vendorQueryApprovedBoolean) Order(direction SortOrder) vendorDefaultParam {
	return vendorDefaultParam{
		data: builder.Field{
			Name:  "approved",
			Value: direction,
		},
	}
}

func (r vendorQueryApprovedBoolean) Cursor(cursor bool) vendorCursorParam {
	return vendorCursorParam{
		data: builder.Field{
			Name:  "approved",
			Value: cursor,
		},
	}
}

func (r vendorQueryApprovedBoolean) Field() vendorPrismaFields {
	return vendorFieldApproved
}

// base struct
type vendorQueryProductProduct struct{}

type vendorQueryProductRelations struct{}

// Vendor -> Product
//
// @relation
// @required
func (vendorQueryProductRelations) Some(
	params ...ProductWhereParam,
) vendorDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorDefaultParam{
		data: builder.Field{
			Name: "Product",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Vendor -> Product
//
// @relation
// @required
func (vendorQueryProductRelations) Every(
	params ...ProductWhereParam,
) vendorDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorDefaultParam{
		data: builder.Field{
			Name: "Product",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Vendor -> Product
//
// @relation
// @required
func (vendorQueryProductRelations) None(
	params ...ProductWhereParam,
) vendorDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorDefaultParam{
		data: builder.Field{
			Name: "Product",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (vendorQueryProductRelations) Fetch(

	params ...ProductWhereParam,

) vendorToProductFindMany {
	var v vendorToProductFindMany

	v.query.Operation = "query"
	v.query.Method = "Product"
	v.query.Outputs = productOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r vendorQueryProductRelations) Link(
	params ...ProductWhereParam,
) vendorSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return vendorSetParam{
		data: builder.Field{
			Name: "Product",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r vendorQueryProductRelations) Unlink(
	params ...ProductWhereParam,
) vendorSetParam {
	var v vendorSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = vendorSetParam{
		data: builder.Field{
			Name: "Product",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r vendorQueryProductProduct) Field() vendorPrismaFields {
	return vendorFieldProduct
}

// Product acts as a namespaces to access query methods for the Product model
var Product = productQuery{}

// productQuery exposes query functions for the product model
type productQuery struct {

	// ID
	//
	// @required
	ID productQueryIDString

	Vendor productQueryVendorRelations

	// VendorID
	//
	// @required
	VendorID productQueryVendorIDString

	// Name
	//
	// @required
	Name productQueryNameString

	// Price
	//
	// @required
	Price productQueryPriceFloat

	// Category
	//
	// @required
	Category productQueryCategoryString

	// ImageURL
	//
	// @required
	ImageURL productQueryImageURLString

	Order productQueryOrderRelations

	Wishlist productQueryWishlistRelations
}

func (productQuery) Not(params ...ProductWhereParam) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (productQuery) Or(params ...ProductWhereParam) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (productQuery) And(params ...ProductWhereParam) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type productQueryIDString struct{}

// Set the required value of ID
func (r productQueryIDString) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r productQueryIDString) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryIDString) Equals(value string) productWithPrismaIDEqualsUniqueParam {

	return productWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) EqualsIfPresent(value *string) productWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return productWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r productQueryIDString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r productQueryIDString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r productQueryIDString) In(value []string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) InIfPresent(value []string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.In(value)
}

func (r productQueryIDString) NotIn(value []string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) NotInIfPresent(value []string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.NotIn(value)
}

func (r productQueryIDString) Lt(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) LtIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Lt(*value)
}

func (r productQueryIDString) Lte(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) LteIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Lte(*value)
}

func (r productQueryIDString) Gt(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) GtIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Gt(*value)
}

func (r productQueryIDString) Gte(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) GteIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Gte(*value)
}

func (r productQueryIDString) Contains(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) ContainsIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Contains(*value)
}

func (r productQueryIDString) StartsWith(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) StartsWithIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r productQueryIDString) EndsWith(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) EndsWithIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r productQueryIDString) Mode(value QueryMode) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) ModeIfPresent(value *QueryMode) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Mode(*value)
}

func (r productQueryIDString) Not(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) NotIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryIDString) HasPrefix(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryIDString) HasPrefixIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryIDString) HasSuffix(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryIDString) HasSuffixIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryIDString) Field() productPrismaFields {
	return productFieldID
}

// base struct
type productQueryVendorVendor struct{}

type productQueryVendorRelations struct{}

// Product -> Vendor
//
// @relation
// @required
func (productQueryVendorRelations) Where(
	params ...VendorWhereParam,
) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name: "vendor",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (productQueryVendorRelations) Fetch() productToVendorFindUnique {
	var v productToVendorFindUnique

	v.query.Operation = "query"
	v.query.Method = "vendor"
	v.query.Outputs = vendorOutput

	return v
}

func (r productQueryVendorRelations) Link(
	params VendorWhereParam,
) productWithPrismaVendorSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return productWithPrismaVendorSetParam{}
	}

	fields = append(fields, f)

	return productWithPrismaVendorSetParam{
		data: builder.Field{
			Name: "vendor",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r productQueryVendorRelations) Unlink() productWithPrismaVendorSetParam {
	var v productWithPrismaVendorSetParam

	v = productWithPrismaVendorSetParam{
		data: builder.Field{
			Name: "vendor",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r productQueryVendorVendor) Field() productPrismaFields {
	return productFieldVendor
}

// base struct
type productQueryVendorIDString struct{}

// Set the required value of VendorID
func (r productQueryVendorIDString) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "vendorId",
			Value: value,
		},
	}

}

// Set the optional value of VendorID dynamically
func (r productQueryVendorIDString) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryVendorIDString) Equals(value string) productWithPrismaVendorIDEqualsParam {

	return productWithPrismaVendorIDEqualsParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) EqualsIfPresent(value *string) productWithPrismaVendorIDEqualsParam {
	if value == nil {
		return productWithPrismaVendorIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryVendorIDString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "vendorId",
			Value: direction,
		},
	}
}

func (r productQueryVendorIDString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "vendorId",
			Value: cursor,
		},
	}
}

func (r productQueryVendorIDString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryVendorIDString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryVendorIDString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryVendorIDString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryVendorIDString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryVendorIDString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryVendorIDString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryVendorIDString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryVendorIDString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryVendorIDString) Mode(value QueryMode) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) ModeIfPresent(value *QueryMode) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Mode(*value)
}

func (r productQueryVendorIDString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryVendorIDString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryVendorIDString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryVendorIDString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryVendorIDString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "vendorId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryVendorIDString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryVendorIDString) Field() productPrismaFields {
	return productFieldVendorID
}

// base struct
type productQueryNameString struct{}

// Set the required value of Name
func (r productQueryNameString) Set(value string) productWithPrismaNameSetParam {

	return productWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r productQueryNameString) SetIfPresent(value *String) productWithPrismaNameSetParam {
	if value == nil {
		return productWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryNameString) Equals(value string) productWithPrismaNameEqualsParam {

	return productWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) EqualsIfPresent(value *string) productWithPrismaNameEqualsParam {
	if value == nil {
		return productWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryNameString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r productQueryNameString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r productQueryNameString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryNameString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryNameString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryNameString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryNameString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryNameString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryNameString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryNameString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryNameString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryNameString) Mode(value QueryMode) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) ModeIfPresent(value *QueryMode) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Mode(*value)
}

func (r productQueryNameString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryNameString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryNameString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryNameString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryNameString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryNameString) Field() productPrismaFields {
	return productFieldName
}

// base struct
type productQueryPriceFloat struct{}

// Set the required value of Price
func (r productQueryPriceFloat) Set(value float64) productWithPrismaPriceSetParam {

	return productWithPrismaPriceSetParam{
		data: builder.Field{
			Name:  "price",
			Value: value,
		},
	}

}

// Set the optional value of Price dynamically
func (r productQueryPriceFloat) SetIfPresent(value *Float) productWithPrismaPriceSetParam {
	if value == nil {
		return productWithPrismaPriceSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Price
func (r productQueryPriceFloat) Increment(value float64) productWithPrismaPriceSetParam {
	return productWithPrismaPriceSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) IncrementIfPresent(value *float64) productWithPrismaPriceSetParam {
	if value == nil {
		return productWithPrismaPriceSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Price
func (r productQueryPriceFloat) Decrement(value float64) productWithPrismaPriceSetParam {
	return productWithPrismaPriceSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) DecrementIfPresent(value *float64) productWithPrismaPriceSetParam {
	if value == nil {
		return productWithPrismaPriceSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Price
func (r productQueryPriceFloat) Multiply(value float64) productWithPrismaPriceSetParam {
	return productWithPrismaPriceSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) MultiplyIfPresent(value *float64) productWithPrismaPriceSetParam {
	if value == nil {
		return productWithPrismaPriceSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Price
func (r productQueryPriceFloat) Divide(value float64) productWithPrismaPriceSetParam {
	return productWithPrismaPriceSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) DivideIfPresent(value *float64) productWithPrismaPriceSetParam {
	if value == nil {
		return productWithPrismaPriceSetParam{}
	}
	return r.Divide(*value)
}

func (r productQueryPriceFloat) Equals(value float64) productWithPrismaPriceEqualsParam {

	return productWithPrismaPriceEqualsParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) EqualsIfPresent(value *float64) productWithPrismaPriceEqualsParam {
	if value == nil {
		return productWithPrismaPriceEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryPriceFloat) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "price",
			Value: direction,
		},
	}
}

func (r productQueryPriceFloat) Cursor(cursor float64) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "price",
			Value: cursor,
		},
	}
}

func (r productQueryPriceFloat) In(value []float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) InIfPresent(value []float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryPriceFloat) NotIn(value []float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) NotInIfPresent(value []float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryPriceFloat) Lt(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) LtIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryPriceFloat) Lte(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) LteIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryPriceFloat) Gt(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) GtIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryPriceFloat) Gte(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) GteIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryPriceFloat) Not(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceFloat) NotIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r productQueryPriceFloat) LT(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r productQueryPriceFloat) LTIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r productQueryPriceFloat) LTE(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r productQueryPriceFloat) LTEIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r productQueryPriceFloat) GT(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r productQueryPriceFloat) GTIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r productQueryPriceFloat) GTE(value float64) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r productQueryPriceFloat) GTEIfPresent(value *float64) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.GTE(*value)
}

func (r productQueryPriceFloat) Field() productPrismaFields {
	return productFieldPrice
}

// base struct
type productQueryCategoryString struct{}

// Set the required value of Category
func (r productQueryCategoryString) Set(value string) productWithPrismaCategorySetParam {

	return productWithPrismaCategorySetParam{
		data: builder.Field{
			Name:  "category",
			Value: value,
		},
	}

}

// Set the optional value of Category dynamically
func (r productQueryCategoryString) SetIfPresent(value *String) productWithPrismaCategorySetParam {
	if value == nil {
		return productWithPrismaCategorySetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCategoryString) Equals(value string) productWithPrismaCategoryEqualsParam {

	return productWithPrismaCategoryEqualsParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) EqualsIfPresent(value *string) productWithPrismaCategoryEqualsParam {
	if value == nil {
		return productWithPrismaCategoryEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCategoryString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "category",
			Value: direction,
		},
	}
}

func (r productQueryCategoryString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "category",
			Value: cursor,
		},
	}
}

func (r productQueryCategoryString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCategoryString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCategoryString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCategoryString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCategoryString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCategoryString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCategoryString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCategoryString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCategoryString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCategoryString) Mode(value QueryMode) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) ModeIfPresent(value *QueryMode) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Mode(*value)
}

func (r productQueryCategoryString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCategoryString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCategoryString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCategoryString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCategoryString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCategoryString) Field() productPrismaFields {
	return productFieldCategory
}

// base struct
type productQueryImageURLString struct{}

// Set the required value of ImageURL
func (r productQueryImageURLString) Set(value string) productWithPrismaImageURLSetParam {

	return productWithPrismaImageURLSetParam{
		data: builder.Field{
			Name:  "imageUrl",
			Value: value,
		},
	}

}

// Set the optional value of ImageURL dynamically
func (r productQueryImageURLString) SetIfPresent(value *String) productWithPrismaImageURLSetParam {
	if value == nil {
		return productWithPrismaImageURLSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryImageURLString) Equals(value string) productWithPrismaImageURLEqualsParam {

	return productWithPrismaImageURLEqualsParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) EqualsIfPresent(value *string) productWithPrismaImageURLEqualsParam {
	if value == nil {
		return productWithPrismaImageURLEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryImageURLString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "imageUrl",
			Value: direction,
		},
	}
}

func (r productQueryImageURLString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "imageUrl",
			Value: cursor,
		},
	}
}

func (r productQueryImageURLString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryImageURLString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryImageURLString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryImageURLString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryImageURLString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryImageURLString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryImageURLString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryImageURLString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryImageURLString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryImageURLString) Mode(value QueryMode) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) ModeIfPresent(value *QueryMode) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Mode(*value)
}

func (r productQueryImageURLString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURLString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryImageURLString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryImageURLString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryImageURLString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryImageURLString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryImageURLString) Field() productPrismaFields {
	return productFieldImageURL
}

// base struct
type productQueryOrderOrder struct{}

type productQueryOrderRelations struct{}

// Product -> Order
//
// @relation
// @required
func (productQueryOrderRelations) Some(
	params ...OrderWhereParam,
) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Product -> Order
//
// @relation
// @required
func (productQueryOrderRelations) Every(
	params ...OrderWhereParam,
) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Product -> Order
//
// @relation
// @required
func (productQueryOrderRelations) None(
	params ...OrderWhereParam,
) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (productQueryOrderRelations) Fetch(

	params ...OrderWhereParam,

) productToOrderFindMany {
	var v productToOrderFindMany

	v.query.Operation = "query"
	v.query.Method = "Order"
	v.query.Outputs = orderOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r productQueryOrderRelations) Link(
	params ...OrderWhereParam,
) productSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productSetParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r productQueryOrderRelations) Unlink(
	params ...OrderWhereParam,
) productSetParam {
	var v productSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = productSetParam{
		data: builder.Field{
			Name: "Order",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r productQueryOrderOrder) Field() productPrismaFields {
	return productFieldOrder
}

// base struct
type productQueryWishlistWishlist struct{}

type productQueryWishlistRelations struct{}

// Product -> Wishlist
//
// @relation
// @required
func (productQueryWishlistRelations) Some(
	params ...WishlistWhereParam,
) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Product -> Wishlist
//
// @relation
// @required
func (productQueryWishlistRelations) Every(
	params ...WishlistWhereParam,
) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Product -> Wishlist
//
// @relation
// @required
func (productQueryWishlistRelations) None(
	params ...WishlistWhereParam,
) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (productQueryWishlistRelations) Fetch(

	params ...WishlistWhereParam,

) productToWishlistFindMany {
	var v productToWishlistFindMany

	v.query.Operation = "query"
	v.query.Method = "Wishlist"
	v.query.Outputs = wishlistOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r productQueryWishlistRelations) Link(
	params ...WishlistWhereParam,
) productSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productSetParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r productQueryWishlistRelations) Unlink(
	params ...WishlistWhereParam,
) productSetParam {
	var v productSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = productSetParam{
		data: builder.Field{
			Name: "Wishlist",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r productQueryWishlistWishlist) Field() productPrismaFields {
	return productFieldWishlist
}

// Order acts as a namespaces to access query methods for the Order model
var Order = orderQuery{}

// orderQuery exposes query functions for the order model
type orderQuery struct {

	// ID
	//
	// @required
	ID orderQueryIDString

	User orderQueryUserRelations

	// UserID
	//
	// @required
	UserID orderQueryUserIDString

	Product orderQueryProductRelations

	// ProductID
	//
	// @required
	ProductID orderQueryProductIDString

	// Quantity
	//
	// @required
	Quantity orderQueryQuantityInt

	// Status
	//
	// @required
	Status orderQueryStatusString
}

func (orderQuery) Not(params ...OrderWhereParam) orderDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orderDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orderQuery) Or(params ...OrderWhereParam) orderDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orderDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orderQuery) And(params ...OrderWhereParam) orderDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orderDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type orderQueryIDString struct{}

// Set the required value of ID
func (r orderQueryIDString) Set(value string) orderSetParam {

	return orderSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r orderQueryIDString) SetIfPresent(value *String) orderSetParam {
	if value == nil {
		return orderSetParam{}
	}

	return r.Set(*value)
}

func (r orderQueryIDString) Equals(value string) orderWithPrismaIDEqualsUniqueParam {

	return orderWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) EqualsIfPresent(value *string) orderWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return orderWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r orderQueryIDString) Order(direction SortOrder) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r orderQueryIDString) Cursor(cursor string) orderCursorParam {
	return orderCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r orderQueryIDString) In(value []string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) InIfPresent(value []string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.In(value)
}

func (r orderQueryIDString) NotIn(value []string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) NotInIfPresent(value []string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.NotIn(value)
}

func (r orderQueryIDString) Lt(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) LtIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.Lt(*value)
}

func (r orderQueryIDString) Lte(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) LteIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.Lte(*value)
}

func (r orderQueryIDString) Gt(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) GtIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.Gt(*value)
}

func (r orderQueryIDString) Gte(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) GteIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.Gte(*value)
}

func (r orderQueryIDString) Contains(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) ContainsIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.Contains(*value)
}

func (r orderQueryIDString) StartsWith(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) StartsWithIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r orderQueryIDString) EndsWith(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) EndsWithIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r orderQueryIDString) Mode(value QueryMode) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) ModeIfPresent(value *QueryMode) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.Mode(*value)
}

func (r orderQueryIDString) Not(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryIDString) NotIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orderQueryIDString) HasPrefix(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orderQueryIDString) HasPrefixIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orderQueryIDString) HasSuffix(value string) orderParamUnique {
	return orderParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orderQueryIDString) HasSuffixIfPresent(value *string) orderParamUnique {
	if value == nil {
		return orderParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r orderQueryIDString) Field() orderPrismaFields {
	return orderFieldID
}

// base struct
type orderQueryUserUser struct{}

type orderQueryUserRelations struct{}

// Order -> User
//
// @relation
// @required
func (orderQueryUserRelations) Where(
	params ...UserWhereParam,
) orderDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orderDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (orderQueryUserRelations) Fetch() orderToUserFindUnique {
	var v orderToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r orderQueryUserRelations) Link(
	params UserWhereParam,
) orderWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return orderWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return orderWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r orderQueryUserRelations) Unlink() orderWithPrismaUserSetParam {
	var v orderWithPrismaUserSetParam

	v = orderWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r orderQueryUserUser) Field() orderPrismaFields {
	return orderFieldUser
}

// base struct
type orderQueryUserIDString struct{}

// Set the required value of UserID
func (r orderQueryUserIDString) Set(value string) orderSetParam {

	return orderSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r orderQueryUserIDString) SetIfPresent(value *String) orderSetParam {
	if value == nil {
		return orderSetParam{}
	}

	return r.Set(*value)
}

func (r orderQueryUserIDString) Equals(value string) orderWithPrismaUserIDEqualsParam {

	return orderWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) EqualsIfPresent(value *string) orderWithPrismaUserIDEqualsParam {
	if value == nil {
		return orderWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orderQueryUserIDString) Order(direction SortOrder) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r orderQueryUserIDString) Cursor(cursor string) orderCursorParam {
	return orderCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r orderQueryUserIDString) In(value []string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) InIfPresent(value []string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.In(value)
}

func (r orderQueryUserIDString) NotIn(value []string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) NotInIfPresent(value []string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orderQueryUserIDString) Lt(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) LtIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orderQueryUserIDString) Lte(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) LteIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orderQueryUserIDString) Gt(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) GtIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orderQueryUserIDString) Gte(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) GteIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orderQueryUserIDString) Contains(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) ContainsIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orderQueryUserIDString) StartsWith(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) StartsWithIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orderQueryUserIDString) EndsWith(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) EndsWithIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orderQueryUserIDString) Mode(value QueryMode) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) ModeIfPresent(value *QueryMode) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orderQueryUserIDString) Not(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryUserIDString) NotIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orderQueryUserIDString) HasPrefix(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orderQueryUserIDString) HasPrefixIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orderQueryUserIDString) HasSuffix(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orderQueryUserIDString) HasSuffixIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orderQueryUserIDString) Field() orderPrismaFields {
	return orderFieldUserID
}

// base struct
type orderQueryProductProduct struct{}

type orderQueryProductRelations struct{}

// Order -> Product
//
// @relation
// @required
func (orderQueryProductRelations) Where(
	params ...ProductWhereParam,
) orderDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orderDefaultParam{
		data: builder.Field{
			Name: "product",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (orderQueryProductRelations) Fetch() orderToProductFindUnique {
	var v orderToProductFindUnique

	v.query.Operation = "query"
	v.query.Method = "product"
	v.query.Outputs = productOutput

	return v
}

func (r orderQueryProductRelations) Link(
	params ProductWhereParam,
) orderWithPrismaProductSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return orderWithPrismaProductSetParam{}
	}

	fields = append(fields, f)

	return orderWithPrismaProductSetParam{
		data: builder.Field{
			Name: "product",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r orderQueryProductRelations) Unlink() orderWithPrismaProductSetParam {
	var v orderWithPrismaProductSetParam

	v = orderWithPrismaProductSetParam{
		data: builder.Field{
			Name: "product",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r orderQueryProductProduct) Field() orderPrismaFields {
	return orderFieldProduct
}

// base struct
type orderQueryProductIDString struct{}

// Set the required value of ProductID
func (r orderQueryProductIDString) Set(value string) orderSetParam {

	return orderSetParam{
		data: builder.Field{
			Name:  "productId",
			Value: value,
		},
	}

}

// Set the optional value of ProductID dynamically
func (r orderQueryProductIDString) SetIfPresent(value *String) orderSetParam {
	if value == nil {
		return orderSetParam{}
	}

	return r.Set(*value)
}

func (r orderQueryProductIDString) Equals(value string) orderWithPrismaProductIDEqualsParam {

	return orderWithPrismaProductIDEqualsParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) EqualsIfPresent(value *string) orderWithPrismaProductIDEqualsParam {
	if value == nil {
		return orderWithPrismaProductIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orderQueryProductIDString) Order(direction SortOrder) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name:  "productId",
			Value: direction,
		},
	}
}

func (r orderQueryProductIDString) Cursor(cursor string) orderCursorParam {
	return orderCursorParam{
		data: builder.Field{
			Name:  "productId",
			Value: cursor,
		},
	}
}

func (r orderQueryProductIDString) In(value []string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) InIfPresent(value []string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.In(value)
}

func (r orderQueryProductIDString) NotIn(value []string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) NotInIfPresent(value []string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orderQueryProductIDString) Lt(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) LtIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orderQueryProductIDString) Lte(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) LteIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orderQueryProductIDString) Gt(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) GtIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orderQueryProductIDString) Gte(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) GteIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orderQueryProductIDString) Contains(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) ContainsIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orderQueryProductIDString) StartsWith(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) StartsWithIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orderQueryProductIDString) EndsWith(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) EndsWithIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orderQueryProductIDString) Mode(value QueryMode) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) ModeIfPresent(value *QueryMode) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orderQueryProductIDString) Not(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryProductIDString) NotIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orderQueryProductIDString) HasPrefix(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orderQueryProductIDString) HasPrefixIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orderQueryProductIDString) HasSuffix(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orderQueryProductIDString) HasSuffixIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orderQueryProductIDString) Field() orderPrismaFields {
	return orderFieldProductID
}

// base struct
type orderQueryQuantityInt struct{}

// Set the required value of Quantity
func (r orderQueryQuantityInt) Set(value int) orderWithPrismaQuantitySetParam {

	return orderWithPrismaQuantitySetParam{
		data: builder.Field{
			Name:  "quantity",
			Value: value,
		},
	}

}

// Set the optional value of Quantity dynamically
func (r orderQueryQuantityInt) SetIfPresent(value *Int) orderWithPrismaQuantitySetParam {
	if value == nil {
		return orderWithPrismaQuantitySetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Quantity
func (r orderQueryQuantityInt) Increment(value int) orderWithPrismaQuantitySetParam {
	return orderWithPrismaQuantitySetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) IncrementIfPresent(value *int) orderWithPrismaQuantitySetParam {
	if value == nil {
		return orderWithPrismaQuantitySetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Quantity
func (r orderQueryQuantityInt) Decrement(value int) orderWithPrismaQuantitySetParam {
	return orderWithPrismaQuantitySetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) DecrementIfPresent(value *int) orderWithPrismaQuantitySetParam {
	if value == nil {
		return orderWithPrismaQuantitySetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Quantity
func (r orderQueryQuantityInt) Multiply(value int) orderWithPrismaQuantitySetParam {
	return orderWithPrismaQuantitySetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) MultiplyIfPresent(value *int) orderWithPrismaQuantitySetParam {
	if value == nil {
		return orderWithPrismaQuantitySetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Quantity
func (r orderQueryQuantityInt) Divide(value int) orderWithPrismaQuantitySetParam {
	return orderWithPrismaQuantitySetParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) DivideIfPresent(value *int) orderWithPrismaQuantitySetParam {
	if value == nil {
		return orderWithPrismaQuantitySetParam{}
	}
	return r.Divide(*value)
}

func (r orderQueryQuantityInt) Equals(value int) orderWithPrismaQuantityEqualsParam {

	return orderWithPrismaQuantityEqualsParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) EqualsIfPresent(value *int) orderWithPrismaQuantityEqualsParam {
	if value == nil {
		return orderWithPrismaQuantityEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orderQueryQuantityInt) Order(direction SortOrder) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name:  "quantity",
			Value: direction,
		},
	}
}

func (r orderQueryQuantityInt) Cursor(cursor int) orderCursorParam {
	return orderCursorParam{
		data: builder.Field{
			Name:  "quantity",
			Value: cursor,
		},
	}
}

func (r orderQueryQuantityInt) In(value []int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) InIfPresent(value []int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.In(value)
}

func (r orderQueryQuantityInt) NotIn(value []int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) NotInIfPresent(value []int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orderQueryQuantityInt) Lt(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) LtIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orderQueryQuantityInt) Lte(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) LteIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orderQueryQuantityInt) Gt(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) GtIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orderQueryQuantityInt) Gte(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) GteIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orderQueryQuantityInt) Not(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryQuantityInt) NotIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r orderQueryQuantityInt) LT(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r orderQueryQuantityInt) LTIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r orderQueryQuantityInt) LTE(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r orderQueryQuantityInt) LTEIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r orderQueryQuantityInt) GT(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r orderQueryQuantityInt) GTIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r orderQueryQuantityInt) GTE(value int) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "quantity",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r orderQueryQuantityInt) GTEIfPresent(value *int) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.GTE(*value)
}

func (r orderQueryQuantityInt) Field() orderPrismaFields {
	return orderFieldQuantity
}

// base struct
type orderQueryStatusString struct{}

// Set the required value of Status
func (r orderQueryStatusString) Set(value string) orderWithPrismaStatusSetParam {

	return orderWithPrismaStatusSetParam{
		data: builder.Field{
			Name:  "status",
			Value: value,
		},
	}

}

// Set the optional value of Status dynamically
func (r orderQueryStatusString) SetIfPresent(value *String) orderWithPrismaStatusSetParam {
	if value == nil {
		return orderWithPrismaStatusSetParam{}
	}

	return r.Set(*value)
}

func (r orderQueryStatusString) Equals(value string) orderWithPrismaStatusEqualsParam {

	return orderWithPrismaStatusEqualsParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) EqualsIfPresent(value *string) orderWithPrismaStatusEqualsParam {
	if value == nil {
		return orderWithPrismaStatusEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orderQueryStatusString) Order(direction SortOrder) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name:  "status",
			Value: direction,
		},
	}
}

func (r orderQueryStatusString) Cursor(cursor string) orderCursorParam {
	return orderCursorParam{
		data: builder.Field{
			Name:  "status",
			Value: cursor,
		},
	}
}

func (r orderQueryStatusString) In(value []string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) InIfPresent(value []string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.In(value)
}

func (r orderQueryStatusString) NotIn(value []string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) NotInIfPresent(value []string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orderQueryStatusString) Lt(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) LtIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orderQueryStatusString) Lte(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) LteIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orderQueryStatusString) Gt(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) GtIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orderQueryStatusString) Gte(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) GteIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orderQueryStatusString) Contains(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) ContainsIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orderQueryStatusString) StartsWith(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) StartsWithIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orderQueryStatusString) EndsWith(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) EndsWithIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orderQueryStatusString) Mode(value QueryMode) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) ModeIfPresent(value *QueryMode) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orderQueryStatusString) Not(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orderQueryStatusString) NotIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orderQueryStatusString) HasPrefix(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orderQueryStatusString) HasPrefixIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orderQueryStatusString) HasSuffix(value string) orderDefaultParam {
	return orderDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orderQueryStatusString) HasSuffixIfPresent(value *string) orderDefaultParam {
	if value == nil {
		return orderDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orderQueryStatusString) Field() orderPrismaFields {
	return orderFieldStatus
}

// Wishlist acts as a namespaces to access query methods for the Wishlist model
var Wishlist = wishlistQuery{}

// wishlistQuery exposes query functions for the wishlist model
type wishlistQuery struct {

	// ID
	//
	// @required
	ID wishlistQueryIDString

	User wishlistQueryUserRelations

	// UserID
	//
	// @required
	UserID wishlistQueryUserIDString

	Product wishlistQueryProductRelations

	// ProductID
	//
	// @required
	ProductID wishlistQueryProductIDString
}

func (wishlistQuery) Not(params ...WishlistWhereParam) wishlistDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return wishlistDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (wishlistQuery) Or(params ...WishlistWhereParam) wishlistDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return wishlistDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (wishlistQuery) And(params ...WishlistWhereParam) wishlistDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return wishlistDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type wishlistQueryIDString struct{}

// Set the required value of ID
func (r wishlistQueryIDString) Set(value string) wishlistSetParam {

	return wishlistSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r wishlistQueryIDString) SetIfPresent(value *String) wishlistSetParam {
	if value == nil {
		return wishlistSetParam{}
	}

	return r.Set(*value)
}

func (r wishlistQueryIDString) Equals(value string) wishlistWithPrismaIDEqualsUniqueParam {

	return wishlistWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) EqualsIfPresent(value *string) wishlistWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return wishlistWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r wishlistQueryIDString) Order(direction SortOrder) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r wishlistQueryIDString) Cursor(cursor string) wishlistCursorParam {
	return wishlistCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r wishlistQueryIDString) In(value []string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) InIfPresent(value []string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.In(value)
}

func (r wishlistQueryIDString) NotIn(value []string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) NotInIfPresent(value []string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.NotIn(value)
}

func (r wishlistQueryIDString) Lt(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) LtIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.Lt(*value)
}

func (r wishlistQueryIDString) Lte(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) LteIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.Lte(*value)
}

func (r wishlistQueryIDString) Gt(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) GtIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.Gt(*value)
}

func (r wishlistQueryIDString) Gte(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) GteIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.Gte(*value)
}

func (r wishlistQueryIDString) Contains(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) ContainsIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.Contains(*value)
}

func (r wishlistQueryIDString) StartsWith(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) StartsWithIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r wishlistQueryIDString) EndsWith(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) EndsWithIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r wishlistQueryIDString) Mode(value QueryMode) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) ModeIfPresent(value *QueryMode) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.Mode(*value)
}

func (r wishlistQueryIDString) Not(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryIDString) NotIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r wishlistQueryIDString) HasPrefix(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r wishlistQueryIDString) HasPrefixIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r wishlistQueryIDString) HasSuffix(value string) wishlistParamUnique {
	return wishlistParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r wishlistQueryIDString) HasSuffixIfPresent(value *string) wishlistParamUnique {
	if value == nil {
		return wishlistParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r wishlistQueryIDString) Field() wishlistPrismaFields {
	return wishlistFieldID
}

// base struct
type wishlistQueryUserUser struct{}

type wishlistQueryUserRelations struct{}

// Wishlist -> User
//
// @relation
// @required
func (wishlistQueryUserRelations) Where(
	params ...UserWhereParam,
) wishlistDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return wishlistDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (wishlistQueryUserRelations) Fetch() wishlistToUserFindUnique {
	var v wishlistToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r wishlistQueryUserRelations) Link(
	params UserWhereParam,
) wishlistWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return wishlistWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return wishlistWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r wishlistQueryUserRelations) Unlink() wishlistWithPrismaUserSetParam {
	var v wishlistWithPrismaUserSetParam

	v = wishlistWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r wishlistQueryUserUser) Field() wishlistPrismaFields {
	return wishlistFieldUser
}

// base struct
type wishlistQueryUserIDString struct{}

// Set the required value of UserID
func (r wishlistQueryUserIDString) Set(value string) wishlistSetParam {

	return wishlistSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r wishlistQueryUserIDString) SetIfPresent(value *String) wishlistSetParam {
	if value == nil {
		return wishlistSetParam{}
	}

	return r.Set(*value)
}

func (r wishlistQueryUserIDString) Equals(value string) wishlistWithPrismaUserIDEqualsParam {

	return wishlistWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) EqualsIfPresent(value *string) wishlistWithPrismaUserIDEqualsParam {
	if value == nil {
		return wishlistWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r wishlistQueryUserIDString) Order(direction SortOrder) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r wishlistQueryUserIDString) Cursor(cursor string) wishlistCursorParam {
	return wishlistCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r wishlistQueryUserIDString) In(value []string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) InIfPresent(value []string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.In(value)
}

func (r wishlistQueryUserIDString) NotIn(value []string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) NotInIfPresent(value []string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.NotIn(value)
}

func (r wishlistQueryUserIDString) Lt(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) LtIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Lt(*value)
}

func (r wishlistQueryUserIDString) Lte(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) LteIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Lte(*value)
}

func (r wishlistQueryUserIDString) Gt(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) GtIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Gt(*value)
}

func (r wishlistQueryUserIDString) Gte(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) GteIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Gte(*value)
}

func (r wishlistQueryUserIDString) Contains(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) ContainsIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Contains(*value)
}

func (r wishlistQueryUserIDString) StartsWith(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) StartsWithIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r wishlistQueryUserIDString) EndsWith(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) EndsWithIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r wishlistQueryUserIDString) Mode(value QueryMode) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) ModeIfPresent(value *QueryMode) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Mode(*value)
}

func (r wishlistQueryUserIDString) Not(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryUserIDString) NotIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r wishlistQueryUserIDString) HasPrefix(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r wishlistQueryUserIDString) HasPrefixIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r wishlistQueryUserIDString) HasSuffix(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r wishlistQueryUserIDString) HasSuffixIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r wishlistQueryUserIDString) Field() wishlistPrismaFields {
	return wishlistFieldUserID
}

// base struct
type wishlistQueryProductProduct struct{}

type wishlistQueryProductRelations struct{}

// Wishlist -> Product
//
// @relation
// @required
func (wishlistQueryProductRelations) Where(
	params ...ProductWhereParam,
) wishlistDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return wishlistDefaultParam{
		data: builder.Field{
			Name: "product",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (wishlistQueryProductRelations) Fetch() wishlistToProductFindUnique {
	var v wishlistToProductFindUnique

	v.query.Operation = "query"
	v.query.Method = "product"
	v.query.Outputs = productOutput

	return v
}

func (r wishlistQueryProductRelations) Link(
	params ProductWhereParam,
) wishlistWithPrismaProductSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return wishlistWithPrismaProductSetParam{}
	}

	fields = append(fields, f)

	return wishlistWithPrismaProductSetParam{
		data: builder.Field{
			Name: "product",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r wishlistQueryProductRelations) Unlink() wishlistWithPrismaProductSetParam {
	var v wishlistWithPrismaProductSetParam

	v = wishlistWithPrismaProductSetParam{
		data: builder.Field{
			Name: "product",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r wishlistQueryProductProduct) Field() wishlistPrismaFields {
	return wishlistFieldProduct
}

// base struct
type wishlistQueryProductIDString struct{}

// Set the required value of ProductID
func (r wishlistQueryProductIDString) Set(value string) wishlistSetParam {

	return wishlistSetParam{
		data: builder.Field{
			Name:  "productId",
			Value: value,
		},
	}

}

// Set the optional value of ProductID dynamically
func (r wishlistQueryProductIDString) SetIfPresent(value *String) wishlistSetParam {
	if value == nil {
		return wishlistSetParam{}
	}

	return r.Set(*value)
}

func (r wishlistQueryProductIDString) Equals(value string) wishlistWithPrismaProductIDEqualsParam {

	return wishlistWithPrismaProductIDEqualsParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) EqualsIfPresent(value *string) wishlistWithPrismaProductIDEqualsParam {
	if value == nil {
		return wishlistWithPrismaProductIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r wishlistQueryProductIDString) Order(direction SortOrder) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name:  "productId",
			Value: direction,
		},
	}
}

func (r wishlistQueryProductIDString) Cursor(cursor string) wishlistCursorParam {
	return wishlistCursorParam{
		data: builder.Field{
			Name:  "productId",
			Value: cursor,
		},
	}
}

func (r wishlistQueryProductIDString) In(value []string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) InIfPresent(value []string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.In(value)
}

func (r wishlistQueryProductIDString) NotIn(value []string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) NotInIfPresent(value []string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.NotIn(value)
}

func (r wishlistQueryProductIDString) Lt(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) LtIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Lt(*value)
}

func (r wishlistQueryProductIDString) Lte(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) LteIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Lte(*value)
}

func (r wishlistQueryProductIDString) Gt(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) GtIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Gt(*value)
}

func (r wishlistQueryProductIDString) Gte(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) GteIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Gte(*value)
}

func (r wishlistQueryProductIDString) Contains(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) ContainsIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Contains(*value)
}

func (r wishlistQueryProductIDString) StartsWith(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) StartsWithIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r wishlistQueryProductIDString) EndsWith(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) EndsWithIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r wishlistQueryProductIDString) Mode(value QueryMode) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) ModeIfPresent(value *QueryMode) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Mode(*value)
}

func (r wishlistQueryProductIDString) Not(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r wishlistQueryProductIDString) NotIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r wishlistQueryProductIDString) HasPrefix(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r wishlistQueryProductIDString) HasPrefixIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r wishlistQueryProductIDString) HasSuffix(value string) wishlistDefaultParam {
	return wishlistDefaultParam{
		data: builder.Field{
			Name: "productId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r wishlistQueryProductIDString) HasSuffixIfPresent(value *string) wishlistDefaultParam {
	if value == nil {
		return wishlistDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r wishlistQueryProductIDString) Field() wishlistPrismaFields {
	return wishlistFieldProductID
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "firstName"},
	{Name: "otherName"},
	{Name: "email"},
	{Name: "password"},
	{Name: "salt"},
	{Name: "role"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaFirstNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	firstNameField()
}

type UserWithPrismaFirstNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameSetParam) userModel() {}

func (p userWithPrismaFirstNameSetParam) firstNameField() {}

type UserWithPrismaFirstNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsParam) userModel() {}

func (p userWithPrismaFirstNameEqualsParam) firstNameField() {}

func (userWithPrismaFirstNameSetParam) settable()  {}
func (userWithPrismaFirstNameEqualsParam) equals() {}

type userWithPrismaFirstNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) userModel()      {}
func (p userWithPrismaFirstNameEqualsUniqueParam) firstNameField() {}

func (userWithPrismaFirstNameEqualsUniqueParam) unique() {}
func (userWithPrismaFirstNameEqualsUniqueParam) equals() {}

type UserWithPrismaOtherNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	otherNameField()
}

type UserWithPrismaOtherNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	otherNameField()
}

type userWithPrismaOtherNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOtherNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOtherNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOtherNameSetParam) userModel() {}

func (p userWithPrismaOtherNameSetParam) otherNameField() {}

type UserWithPrismaOtherNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	otherNameField()
}

type userWithPrismaOtherNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOtherNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOtherNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOtherNameEqualsParam) userModel() {}

func (p userWithPrismaOtherNameEqualsParam) otherNameField() {}

func (userWithPrismaOtherNameSetParam) settable()  {}
func (userWithPrismaOtherNameEqualsParam) equals() {}

type userWithPrismaOtherNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOtherNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOtherNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOtherNameEqualsUniqueParam) userModel()      {}
func (p userWithPrismaOtherNameEqualsUniqueParam) otherNameField() {}

func (userWithPrismaOtherNameEqualsUniqueParam) unique() {}
func (userWithPrismaOtherNameEqualsUniqueParam) equals() {}

type UserWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	emailField()
}

type UserWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailSetParam) userModel() {}

func (p userWithPrismaEmailSetParam) emailField() {}

type UserWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsParam) userModel() {}

func (p userWithPrismaEmailEqualsParam) emailField() {}

func (userWithPrismaEmailSetParam) settable()  {}
func (userWithPrismaEmailEqualsParam) equals() {}

type userWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsUniqueParam) userModel()  {}
func (p userWithPrismaEmailEqualsUniqueParam) emailField() {}

func (userWithPrismaEmailEqualsUniqueParam) unique() {}
func (userWithPrismaEmailEqualsUniqueParam) equals() {}

type UserWithPrismaPasswordEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	passwordField()
}

type UserWithPrismaPasswordSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordSetParam) userModel() {}

func (p userWithPrismaPasswordSetParam) passwordField() {}

type UserWithPrismaPasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsParam) userModel() {}

func (p userWithPrismaPasswordEqualsParam) passwordField() {}

func (userWithPrismaPasswordSetParam) settable()  {}
func (userWithPrismaPasswordEqualsParam) equals() {}

type userWithPrismaPasswordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsUniqueParam) userModel()     {}
func (p userWithPrismaPasswordEqualsUniqueParam) passwordField() {}

func (userWithPrismaPasswordEqualsUniqueParam) unique() {}
func (userWithPrismaPasswordEqualsUniqueParam) equals() {}

type UserWithPrismaSaltEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	saltField()
}

type UserWithPrismaSaltSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	saltField()
}

type userWithPrismaSaltSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSaltSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSaltSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSaltSetParam) userModel() {}

func (p userWithPrismaSaltSetParam) saltField() {}

type UserWithPrismaSaltWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	saltField()
}

type userWithPrismaSaltEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSaltEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSaltEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSaltEqualsParam) userModel() {}

func (p userWithPrismaSaltEqualsParam) saltField() {}

func (userWithPrismaSaltSetParam) settable()  {}
func (userWithPrismaSaltEqualsParam) equals() {}

type userWithPrismaSaltEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSaltEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSaltEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSaltEqualsUniqueParam) userModel() {}
func (p userWithPrismaSaltEqualsUniqueParam) saltField() {}

func (userWithPrismaSaltEqualsUniqueParam) unique() {}
func (userWithPrismaSaltEqualsUniqueParam) equals() {}

type UserWithPrismaRoleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	roleField()
}

type UserWithPrismaRoleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	roleField()
}

type userWithPrismaRoleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleSetParam) userModel() {}

func (p userWithPrismaRoleSetParam) roleField() {}

type UserWithPrismaRoleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	roleField()
}

type userWithPrismaRoleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleEqualsParam) userModel() {}

func (p userWithPrismaRoleEqualsParam) roleField() {}

func (userWithPrismaRoleSetParam) settable()  {}
func (userWithPrismaRoleEqualsParam) equals() {}

type userWithPrismaRoleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleEqualsUniqueParam) userModel() {}
func (p userWithPrismaRoleEqualsUniqueParam) roleField() {}

func (userWithPrismaRoleEqualsUniqueParam) unique() {}
func (userWithPrismaRoleEqualsUniqueParam) equals() {}

type UserWithPrismaVendorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	vendorField()
}

type UserWithPrismaVendorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	vendorField()
}

type userWithPrismaVendorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaVendorSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaVendorSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaVendorSetParam) userModel() {}

func (p userWithPrismaVendorSetParam) vendorField() {}

type UserWithPrismaVendorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	vendorField()
}

type userWithPrismaVendorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaVendorEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaVendorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaVendorEqualsParam) userModel() {}

func (p userWithPrismaVendorEqualsParam) vendorField() {}

func (userWithPrismaVendorSetParam) settable()  {}
func (userWithPrismaVendorEqualsParam) equals() {}

type userWithPrismaVendorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaVendorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaVendorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaVendorEqualsUniqueParam) userModel()   {}
func (p userWithPrismaVendorEqualsUniqueParam) vendorField() {}

func (userWithPrismaVendorEqualsUniqueParam) unique() {}
func (userWithPrismaVendorEqualsUniqueParam) equals() {}

type UserWithPrismaOrderEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	orderField()
}

type UserWithPrismaOrderSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	orderField()
}

type userWithPrismaOrderSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOrderSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOrderSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOrderSetParam) userModel() {}

func (p userWithPrismaOrderSetParam) orderField() {}

type UserWithPrismaOrderWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	orderField()
}

type userWithPrismaOrderEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOrderEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOrderEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOrderEqualsParam) userModel() {}

func (p userWithPrismaOrderEqualsParam) orderField() {}

func (userWithPrismaOrderSetParam) settable()  {}
func (userWithPrismaOrderEqualsParam) equals() {}

type userWithPrismaOrderEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOrderEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOrderEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOrderEqualsUniqueParam) userModel()  {}
func (p userWithPrismaOrderEqualsUniqueParam) orderField() {}

func (userWithPrismaOrderEqualsUniqueParam) unique() {}
func (userWithPrismaOrderEqualsUniqueParam) equals() {}

type UserWithPrismaWishlistEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	wishlistField()
}

type UserWithPrismaWishlistSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	wishlistField()
}

type userWithPrismaWishlistSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaWishlistSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaWishlistSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaWishlistSetParam) userModel() {}

func (p userWithPrismaWishlistSetParam) wishlistField() {}

type UserWithPrismaWishlistWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	wishlistField()
}

type userWithPrismaWishlistEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaWishlistEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaWishlistEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaWishlistEqualsParam) userModel() {}

func (p userWithPrismaWishlistEqualsParam) wishlistField() {}

func (userWithPrismaWishlistSetParam) settable()  {}
func (userWithPrismaWishlistEqualsParam) equals() {}

type userWithPrismaWishlistEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaWishlistEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaWishlistEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaWishlistEqualsUniqueParam) userModel()     {}
func (p userWithPrismaWishlistEqualsUniqueParam) wishlistField() {}

func (userWithPrismaWishlistEqualsUniqueParam) unique() {}
func (userWithPrismaWishlistEqualsUniqueParam) equals() {}

type vendorActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var vendorOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "business_name"},
	{Name: "tax_pin"},
	{Name: "approved"},
}

type VendorRelationWith interface {
	getQuery() builder.Query
	with()
	vendorRelation()
}

type VendorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
}

type vendorDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorDefaultParam) field() builder.Field {
	return p.data
}

func (p vendorDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p vendorDefaultParam) vendorModel() {}

type VendorOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
}

type vendorOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorOrderByParam) field() builder.Field {
	return p.data
}

func (p vendorOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p vendorOrderByParam) vendorModel() {}

type VendorCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	isCursor()
}

type vendorCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorCursorParam) field() builder.Field {
	return p.data
}

func (p vendorCursorParam) isCursor() {}

func (p vendorCursorParam) getQuery() builder.Query {
	return p.query
}

func (p vendorCursorParam) vendorModel() {}

type VendorParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	vendorModel()
}

type vendorParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p vendorParamUnique) vendorModel() {}

func (vendorParamUnique) unique() {}

func (p vendorParamUnique) field() builder.Field {
	return p.data
}

func (p vendorParamUnique) getQuery() builder.Query {
	return p.query
}

type VendorEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
}

type vendorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorEqualsParam) vendorModel() {}

func (vendorEqualsParam) equals() {}

func (p vendorEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorEqualsParam) getQuery() builder.Query {
	return p.query
}

type VendorEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	vendorModel()
}

type vendorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorEqualsUniqueParam) vendorModel() {}

func (vendorEqualsUniqueParam) unique() {}
func (vendorEqualsUniqueParam) equals() {}

func (p vendorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type VendorSetParam interface {
	field() builder.Field
	settable()
	vendorModel()
}

type vendorSetParam struct {
	data builder.Field
}

func (vendorSetParam) settable() {}

func (p vendorSetParam) field() builder.Field {
	return p.data
}

func (p vendorSetParam) vendorModel() {}

type VendorWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
	idField()
}

type VendorWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	idField()
}

type vendorWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaIDSetParam) vendorModel() {}

func (p vendorWithPrismaIDSetParam) idField() {}

type VendorWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	idField()
}

type vendorWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaIDEqualsParam) vendorModel() {}

func (p vendorWithPrismaIDEqualsParam) idField() {}

func (vendorWithPrismaIDSetParam) settable()  {}
func (vendorWithPrismaIDEqualsParam) equals() {}

type vendorWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaIDEqualsUniqueParam) vendorModel() {}
func (p vendorWithPrismaIDEqualsUniqueParam) idField()     {}

func (vendorWithPrismaIDEqualsUniqueParam) unique() {}
func (vendorWithPrismaIDEqualsUniqueParam) equals() {}

type VendorWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
	userField()
}

type VendorWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	userField()
}

type vendorWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaUserSetParam) vendorModel() {}

func (p vendorWithPrismaUserSetParam) userField() {}

type VendorWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	userField()
}

type vendorWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaUserEqualsParam) vendorModel() {}

func (p vendorWithPrismaUserEqualsParam) userField() {}

func (vendorWithPrismaUserSetParam) settable()  {}
func (vendorWithPrismaUserEqualsParam) equals() {}

type vendorWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaUserEqualsUniqueParam) vendorModel() {}
func (p vendorWithPrismaUserEqualsUniqueParam) userField()   {}

func (vendorWithPrismaUserEqualsUniqueParam) unique() {}
func (vendorWithPrismaUserEqualsUniqueParam) equals() {}

type VendorWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
	userIDField()
}

type VendorWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	userIDField()
}

type vendorWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaUserIDSetParam) vendorModel() {}

func (p vendorWithPrismaUserIDSetParam) userIDField() {}

type VendorWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	userIDField()
}

type vendorWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaUserIDEqualsParam) vendorModel() {}

func (p vendorWithPrismaUserIDEqualsParam) userIDField() {}

func (vendorWithPrismaUserIDSetParam) settable()  {}
func (vendorWithPrismaUserIDEqualsParam) equals() {}

type vendorWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaUserIDEqualsUniqueParam) vendorModel() {}
func (p vendorWithPrismaUserIDEqualsUniqueParam) userIDField() {}

func (vendorWithPrismaUserIDEqualsUniqueParam) unique() {}
func (vendorWithPrismaUserIDEqualsUniqueParam) equals() {}

type VendorWithPrismaBusinessNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
	businessNameField()
}

type VendorWithPrismaBusinessNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	businessNameField()
}

type vendorWithPrismaBusinessNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaBusinessNameSetParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaBusinessNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaBusinessNameSetParam) vendorModel() {}

func (p vendorWithPrismaBusinessNameSetParam) businessNameField() {}

type VendorWithPrismaBusinessNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	businessNameField()
}

type vendorWithPrismaBusinessNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaBusinessNameEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaBusinessNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaBusinessNameEqualsParam) vendorModel() {}

func (p vendorWithPrismaBusinessNameEqualsParam) businessNameField() {}

func (vendorWithPrismaBusinessNameSetParam) settable()  {}
func (vendorWithPrismaBusinessNameEqualsParam) equals() {}

type vendorWithPrismaBusinessNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaBusinessNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaBusinessNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaBusinessNameEqualsUniqueParam) vendorModel()       {}
func (p vendorWithPrismaBusinessNameEqualsUniqueParam) businessNameField() {}

func (vendorWithPrismaBusinessNameEqualsUniqueParam) unique() {}
func (vendorWithPrismaBusinessNameEqualsUniqueParam) equals() {}

type VendorWithPrismaTaxPinEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
	taxPinField()
}

type VendorWithPrismaTaxPinSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	taxPinField()
}

type vendorWithPrismaTaxPinSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaTaxPinSetParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaTaxPinSetParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaTaxPinSetParam) vendorModel() {}

func (p vendorWithPrismaTaxPinSetParam) taxPinField() {}

type VendorWithPrismaTaxPinWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	taxPinField()
}

type vendorWithPrismaTaxPinEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaTaxPinEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaTaxPinEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaTaxPinEqualsParam) vendorModel() {}

func (p vendorWithPrismaTaxPinEqualsParam) taxPinField() {}

func (vendorWithPrismaTaxPinSetParam) settable()  {}
func (vendorWithPrismaTaxPinEqualsParam) equals() {}

type vendorWithPrismaTaxPinEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaTaxPinEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaTaxPinEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaTaxPinEqualsUniqueParam) vendorModel() {}
func (p vendorWithPrismaTaxPinEqualsUniqueParam) taxPinField() {}

func (vendorWithPrismaTaxPinEqualsUniqueParam) unique() {}
func (vendorWithPrismaTaxPinEqualsUniqueParam) equals() {}

type VendorWithPrismaApprovedEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
	approvedField()
}

type VendorWithPrismaApprovedSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	approvedField()
}

type vendorWithPrismaApprovedSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaApprovedSetParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaApprovedSetParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaApprovedSetParam) vendorModel() {}

func (p vendorWithPrismaApprovedSetParam) approvedField() {}

type VendorWithPrismaApprovedWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	approvedField()
}

type vendorWithPrismaApprovedEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaApprovedEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaApprovedEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaApprovedEqualsParam) vendorModel() {}

func (p vendorWithPrismaApprovedEqualsParam) approvedField() {}

func (vendorWithPrismaApprovedSetParam) settable()  {}
func (vendorWithPrismaApprovedEqualsParam) equals() {}

type vendorWithPrismaApprovedEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaApprovedEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaApprovedEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaApprovedEqualsUniqueParam) vendorModel()   {}
func (p vendorWithPrismaApprovedEqualsUniqueParam) approvedField() {}

func (vendorWithPrismaApprovedEqualsUniqueParam) unique() {}
func (vendorWithPrismaApprovedEqualsUniqueParam) equals() {}

type VendorWithPrismaProductEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	vendorModel()
	productField()
}

type VendorWithPrismaProductSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	productField()
}

type vendorWithPrismaProductSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaProductSetParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaProductSetParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaProductSetParam) vendorModel() {}

func (p vendorWithPrismaProductSetParam) productField() {}

type VendorWithPrismaProductWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	vendorModel()
	productField()
}

type vendorWithPrismaProductEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaProductEqualsParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaProductEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaProductEqualsParam) vendorModel() {}

func (p vendorWithPrismaProductEqualsParam) productField() {}

func (vendorWithPrismaProductSetParam) settable()  {}
func (vendorWithPrismaProductEqualsParam) equals() {}

type vendorWithPrismaProductEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p vendorWithPrismaProductEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p vendorWithPrismaProductEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p vendorWithPrismaProductEqualsUniqueParam) vendorModel()  {}
func (p vendorWithPrismaProductEqualsUniqueParam) productField() {}

func (vendorWithPrismaProductEqualsUniqueParam) unique() {}
func (vendorWithPrismaProductEqualsUniqueParam) equals() {}

type productActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var productOutput = []builder.Output{
	{Name: "id"},
	{Name: "vendorId"},
	{Name: "name"},
	{Name: "price"},
	{Name: "category"},
	{Name: "imageUrl"},
}

type ProductRelationWith interface {
	getQuery() builder.Query
	with()
	productRelation()
}

type ProductWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
}

type productDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p productDefaultParam) field() builder.Field {
	return p.data
}

func (p productDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p productDefaultParam) productModel() {}

type ProductOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
}

type productOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p productOrderByParam) field() builder.Field {
	return p.data
}

func (p productOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p productOrderByParam) productModel() {}

type ProductCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	isCursor()
}

type productCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p productCursorParam) field() builder.Field {
	return p.data
}

func (p productCursorParam) isCursor() {}

func (p productCursorParam) getQuery() builder.Query {
	return p.query
}

func (p productCursorParam) productModel() {}

type ProductParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	productModel()
}

type productParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p productParamUnique) productModel() {}

func (productParamUnique) unique() {}

func (p productParamUnique) field() builder.Field {
	return p.data
}

func (p productParamUnique) getQuery() builder.Query {
	return p.query
}

type ProductEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
}

type productEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productEqualsParam) productModel() {}

func (productEqualsParam) equals() {}

func (p productEqualsParam) field() builder.Field {
	return p.data
}

func (p productEqualsParam) getQuery() builder.Query {
	return p.query
}

type ProductEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	productModel()
}

type productEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productEqualsUniqueParam) productModel() {}

func (productEqualsUniqueParam) unique() {}
func (productEqualsUniqueParam) equals() {}

func (p productEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ProductSetParam interface {
	field() builder.Field
	settable()
	productModel()
}

type productSetParam struct {
	data builder.Field
}

func (productSetParam) settable() {}

func (p productSetParam) field() builder.Field {
	return p.data
}

func (p productSetParam) productModel() {}

type ProductWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	idField()
}

type ProductWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	idField()
}

type productWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaIDSetParam) productModel() {}

func (p productWithPrismaIDSetParam) idField() {}

type ProductWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	idField()
}

type productWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaIDEqualsParam) productModel() {}

func (p productWithPrismaIDEqualsParam) idField() {}

func (productWithPrismaIDSetParam) settable()  {}
func (productWithPrismaIDEqualsParam) equals() {}

type productWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaIDEqualsUniqueParam) productModel() {}
func (p productWithPrismaIDEqualsUniqueParam) idField()      {}

func (productWithPrismaIDEqualsUniqueParam) unique() {}
func (productWithPrismaIDEqualsUniqueParam) equals() {}

type ProductWithPrismaVendorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	vendorField()
}

type ProductWithPrismaVendorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	vendorField()
}

type productWithPrismaVendorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaVendorSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaVendorSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaVendorSetParam) productModel() {}

func (p productWithPrismaVendorSetParam) vendorField() {}

type ProductWithPrismaVendorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	vendorField()
}

type productWithPrismaVendorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaVendorEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaVendorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaVendorEqualsParam) productModel() {}

func (p productWithPrismaVendorEqualsParam) vendorField() {}

func (productWithPrismaVendorSetParam) settable()  {}
func (productWithPrismaVendorEqualsParam) equals() {}

type productWithPrismaVendorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaVendorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaVendorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaVendorEqualsUniqueParam) productModel() {}
func (p productWithPrismaVendorEqualsUniqueParam) vendorField()  {}

func (productWithPrismaVendorEqualsUniqueParam) unique() {}
func (productWithPrismaVendorEqualsUniqueParam) equals() {}

type ProductWithPrismaVendorIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	vendorIDField()
}

type ProductWithPrismaVendorIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	vendorIDField()
}

type productWithPrismaVendorIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaVendorIDSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaVendorIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaVendorIDSetParam) productModel() {}

func (p productWithPrismaVendorIDSetParam) vendorIDField() {}

type ProductWithPrismaVendorIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	vendorIDField()
}

type productWithPrismaVendorIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaVendorIDEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaVendorIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaVendorIDEqualsParam) productModel() {}

func (p productWithPrismaVendorIDEqualsParam) vendorIDField() {}

func (productWithPrismaVendorIDSetParam) settable()  {}
func (productWithPrismaVendorIDEqualsParam) equals() {}

type productWithPrismaVendorIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaVendorIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaVendorIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaVendorIDEqualsUniqueParam) productModel()  {}
func (p productWithPrismaVendorIDEqualsUniqueParam) vendorIDField() {}

func (productWithPrismaVendorIDEqualsUniqueParam) unique() {}
func (productWithPrismaVendorIDEqualsUniqueParam) equals() {}

type ProductWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	nameField()
}

type ProductWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	nameField()
}

type productWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNameSetParam) productModel() {}

func (p productWithPrismaNameSetParam) nameField() {}

type ProductWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	nameField()
}

type productWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNameEqualsParam) productModel() {}

func (p productWithPrismaNameEqualsParam) nameField() {}

func (productWithPrismaNameSetParam) settable()  {}
func (productWithPrismaNameEqualsParam) equals() {}

type productWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNameEqualsUniqueParam) productModel() {}
func (p productWithPrismaNameEqualsUniqueParam) nameField()    {}

func (productWithPrismaNameEqualsUniqueParam) unique() {}
func (productWithPrismaNameEqualsUniqueParam) equals() {}

type ProductWithPrismaPriceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	priceField()
}

type ProductWithPrismaPriceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	priceField()
}

type productWithPrismaPriceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaPriceSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaPriceSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaPriceSetParam) productModel() {}

func (p productWithPrismaPriceSetParam) priceField() {}

type ProductWithPrismaPriceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	priceField()
}

type productWithPrismaPriceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaPriceEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaPriceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaPriceEqualsParam) productModel() {}

func (p productWithPrismaPriceEqualsParam) priceField() {}

func (productWithPrismaPriceSetParam) settable()  {}
func (productWithPrismaPriceEqualsParam) equals() {}

type productWithPrismaPriceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaPriceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaPriceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaPriceEqualsUniqueParam) productModel() {}
func (p productWithPrismaPriceEqualsUniqueParam) priceField()   {}

func (productWithPrismaPriceEqualsUniqueParam) unique() {}
func (productWithPrismaPriceEqualsUniqueParam) equals() {}

type ProductWithPrismaCategoryEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	categoryField()
}

type ProductWithPrismaCategorySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryField()
}

type productWithPrismaCategorySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategorySetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategorySetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategorySetParam) productModel() {}

func (p productWithPrismaCategorySetParam) categoryField() {}

type ProductWithPrismaCategoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryField()
}

type productWithPrismaCategoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryEqualsParam) productModel() {}

func (p productWithPrismaCategoryEqualsParam) categoryField() {}

func (productWithPrismaCategorySetParam) settable()  {}
func (productWithPrismaCategoryEqualsParam) equals() {}

type productWithPrismaCategoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryEqualsUniqueParam) productModel()  {}
func (p productWithPrismaCategoryEqualsUniqueParam) categoryField() {}

func (productWithPrismaCategoryEqualsUniqueParam) unique() {}
func (productWithPrismaCategoryEqualsUniqueParam) equals() {}

type ProductWithPrismaImageURLEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	imageURLField()
}

type ProductWithPrismaImageURLSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	imageURLField()
}

type productWithPrismaImageURLSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURLSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURLSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURLSetParam) productModel() {}

func (p productWithPrismaImageURLSetParam) imageURLField() {}

type ProductWithPrismaImageURLWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	imageURLField()
}

type productWithPrismaImageURLEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURLEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURLEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURLEqualsParam) productModel() {}

func (p productWithPrismaImageURLEqualsParam) imageURLField() {}

func (productWithPrismaImageURLSetParam) settable()  {}
func (productWithPrismaImageURLEqualsParam) equals() {}

type productWithPrismaImageURLEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURLEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURLEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURLEqualsUniqueParam) productModel()  {}
func (p productWithPrismaImageURLEqualsUniqueParam) imageURLField() {}

func (productWithPrismaImageURLEqualsUniqueParam) unique() {}
func (productWithPrismaImageURLEqualsUniqueParam) equals() {}

type ProductWithPrismaOrderEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	orderField()
}

type ProductWithPrismaOrderSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	orderField()
}

type productWithPrismaOrderSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaOrderSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaOrderSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaOrderSetParam) productModel() {}

func (p productWithPrismaOrderSetParam) orderField() {}

type ProductWithPrismaOrderWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	orderField()
}

type productWithPrismaOrderEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaOrderEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaOrderEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaOrderEqualsParam) productModel() {}

func (p productWithPrismaOrderEqualsParam) orderField() {}

func (productWithPrismaOrderSetParam) settable()  {}
func (productWithPrismaOrderEqualsParam) equals() {}

type productWithPrismaOrderEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaOrderEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaOrderEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaOrderEqualsUniqueParam) productModel() {}
func (p productWithPrismaOrderEqualsUniqueParam) orderField()   {}

func (productWithPrismaOrderEqualsUniqueParam) unique() {}
func (productWithPrismaOrderEqualsUniqueParam) equals() {}

type ProductWithPrismaWishlistEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	wishlistField()
}

type ProductWithPrismaWishlistSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	wishlistField()
}

type productWithPrismaWishlistSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaWishlistSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaWishlistSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaWishlistSetParam) productModel() {}

func (p productWithPrismaWishlistSetParam) wishlistField() {}

type ProductWithPrismaWishlistWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	wishlistField()
}

type productWithPrismaWishlistEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaWishlistEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaWishlistEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaWishlistEqualsParam) productModel() {}

func (p productWithPrismaWishlistEqualsParam) wishlistField() {}

func (productWithPrismaWishlistSetParam) settable()  {}
func (productWithPrismaWishlistEqualsParam) equals() {}

type productWithPrismaWishlistEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaWishlistEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaWishlistEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaWishlistEqualsUniqueParam) productModel()  {}
func (p productWithPrismaWishlistEqualsUniqueParam) wishlistField() {}

func (productWithPrismaWishlistEqualsUniqueParam) unique() {}
func (productWithPrismaWishlistEqualsUniqueParam) equals() {}

type orderActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var orderOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "productId"},
	{Name: "quantity"},
	{Name: "status"},
}

type OrderRelationWith interface {
	getQuery() builder.Query
	with()
	orderRelation()
}

type OrderWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
}

type orderDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderDefaultParam) field() builder.Field {
	return p.data
}

func (p orderDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p orderDefaultParam) orderModel() {}

type OrderOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
}

type orderOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderOrderByParam) field() builder.Field {
	return p.data
}

func (p orderOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p orderOrderByParam) orderModel() {}

type OrderCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	isCursor()
}

type orderCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderCursorParam) field() builder.Field {
	return p.data
}

func (p orderCursorParam) isCursor() {}

func (p orderCursorParam) getQuery() builder.Query {
	return p.query
}

func (p orderCursorParam) orderModel() {}

type OrderParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	orderModel()
}

type orderParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p orderParamUnique) orderModel() {}

func (orderParamUnique) unique() {}

func (p orderParamUnique) field() builder.Field {
	return p.data
}

func (p orderParamUnique) getQuery() builder.Query {
	return p.query
}

type OrderEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
}

type orderEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderEqualsParam) orderModel() {}

func (orderEqualsParam) equals() {}

func (p orderEqualsParam) field() builder.Field {
	return p.data
}

func (p orderEqualsParam) getQuery() builder.Query {
	return p.query
}

type OrderEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	orderModel()
}

type orderEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderEqualsUniqueParam) orderModel() {}

func (orderEqualsUniqueParam) unique() {}
func (orderEqualsUniqueParam) equals() {}

func (p orderEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type OrderSetParam interface {
	field() builder.Field
	settable()
	orderModel()
}

type orderSetParam struct {
	data builder.Field
}

func (orderSetParam) settable() {}

func (p orderSetParam) field() builder.Field {
	return p.data
}

func (p orderSetParam) orderModel() {}

type OrderWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
	idField()
}

type OrderWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	idField()
}

type orderWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaIDSetParam) orderModel() {}

func (p orderWithPrismaIDSetParam) idField() {}

type OrderWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	idField()
}

type orderWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaIDEqualsParam) orderModel() {}

func (p orderWithPrismaIDEqualsParam) idField() {}

func (orderWithPrismaIDSetParam) settable()  {}
func (orderWithPrismaIDEqualsParam) equals() {}

type orderWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaIDEqualsUniqueParam) orderModel() {}
func (p orderWithPrismaIDEqualsUniqueParam) idField()    {}

func (orderWithPrismaIDEqualsUniqueParam) unique() {}
func (orderWithPrismaIDEqualsUniqueParam) equals() {}

type OrderWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
	userField()
}

type OrderWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	userField()
}

type orderWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaUserSetParam) orderModel() {}

func (p orderWithPrismaUserSetParam) userField() {}

type OrderWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	userField()
}

type orderWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaUserEqualsParam) orderModel() {}

func (p orderWithPrismaUserEqualsParam) userField() {}

func (orderWithPrismaUserSetParam) settable()  {}
func (orderWithPrismaUserEqualsParam) equals() {}

type orderWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaUserEqualsUniqueParam) orderModel() {}
func (p orderWithPrismaUserEqualsUniqueParam) userField()  {}

func (orderWithPrismaUserEqualsUniqueParam) unique() {}
func (orderWithPrismaUserEqualsUniqueParam) equals() {}

type OrderWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
	userIDField()
}

type OrderWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	userIDField()
}

type orderWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaUserIDSetParam) orderModel() {}

func (p orderWithPrismaUserIDSetParam) userIDField() {}

type OrderWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	userIDField()
}

type orderWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaUserIDEqualsParam) orderModel() {}

func (p orderWithPrismaUserIDEqualsParam) userIDField() {}

func (orderWithPrismaUserIDSetParam) settable()  {}
func (orderWithPrismaUserIDEqualsParam) equals() {}

type orderWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaUserIDEqualsUniqueParam) orderModel()  {}
func (p orderWithPrismaUserIDEqualsUniqueParam) userIDField() {}

func (orderWithPrismaUserIDEqualsUniqueParam) unique() {}
func (orderWithPrismaUserIDEqualsUniqueParam) equals() {}

type OrderWithPrismaProductEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
	productField()
}

type OrderWithPrismaProductSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	productField()
}

type orderWithPrismaProductSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaProductSetParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaProductSetParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaProductSetParam) orderModel() {}

func (p orderWithPrismaProductSetParam) productField() {}

type OrderWithPrismaProductWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	productField()
}

type orderWithPrismaProductEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaProductEqualsParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaProductEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaProductEqualsParam) orderModel() {}

func (p orderWithPrismaProductEqualsParam) productField() {}

func (orderWithPrismaProductSetParam) settable()  {}
func (orderWithPrismaProductEqualsParam) equals() {}

type orderWithPrismaProductEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaProductEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaProductEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaProductEqualsUniqueParam) orderModel()   {}
func (p orderWithPrismaProductEqualsUniqueParam) productField() {}

func (orderWithPrismaProductEqualsUniqueParam) unique() {}
func (orderWithPrismaProductEqualsUniqueParam) equals() {}

type OrderWithPrismaProductIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
	productIDField()
}

type OrderWithPrismaProductIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	productIDField()
}

type orderWithPrismaProductIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaProductIDSetParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaProductIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaProductIDSetParam) orderModel() {}

func (p orderWithPrismaProductIDSetParam) productIDField() {}

type OrderWithPrismaProductIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	productIDField()
}

type orderWithPrismaProductIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaProductIDEqualsParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaProductIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaProductIDEqualsParam) orderModel() {}

func (p orderWithPrismaProductIDEqualsParam) productIDField() {}

func (orderWithPrismaProductIDSetParam) settable()  {}
func (orderWithPrismaProductIDEqualsParam) equals() {}

type orderWithPrismaProductIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaProductIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaProductIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaProductIDEqualsUniqueParam) orderModel()     {}
func (p orderWithPrismaProductIDEqualsUniqueParam) productIDField() {}

func (orderWithPrismaProductIDEqualsUniqueParam) unique() {}
func (orderWithPrismaProductIDEqualsUniqueParam) equals() {}

type OrderWithPrismaQuantityEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
	quantityField()
}

type OrderWithPrismaQuantitySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	quantityField()
}

type orderWithPrismaQuantitySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaQuantitySetParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaQuantitySetParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaQuantitySetParam) orderModel() {}

func (p orderWithPrismaQuantitySetParam) quantityField() {}

type OrderWithPrismaQuantityWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	quantityField()
}

type orderWithPrismaQuantityEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaQuantityEqualsParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaQuantityEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaQuantityEqualsParam) orderModel() {}

func (p orderWithPrismaQuantityEqualsParam) quantityField() {}

func (orderWithPrismaQuantitySetParam) settable()  {}
func (orderWithPrismaQuantityEqualsParam) equals() {}

type orderWithPrismaQuantityEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaQuantityEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaQuantityEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaQuantityEqualsUniqueParam) orderModel()    {}
func (p orderWithPrismaQuantityEqualsUniqueParam) quantityField() {}

func (orderWithPrismaQuantityEqualsUniqueParam) unique() {}
func (orderWithPrismaQuantityEqualsUniqueParam) equals() {}

type OrderWithPrismaStatusEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orderModel()
	statusField()
}

type OrderWithPrismaStatusSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	statusField()
}

type orderWithPrismaStatusSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaStatusSetParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaStatusSetParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaStatusSetParam) orderModel() {}

func (p orderWithPrismaStatusSetParam) statusField() {}

type OrderWithPrismaStatusWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orderModel()
	statusField()
}

type orderWithPrismaStatusEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaStatusEqualsParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaStatusEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaStatusEqualsParam) orderModel() {}

func (p orderWithPrismaStatusEqualsParam) statusField() {}

func (orderWithPrismaStatusSetParam) settable()  {}
func (orderWithPrismaStatusEqualsParam) equals() {}

type orderWithPrismaStatusEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orderWithPrismaStatusEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orderWithPrismaStatusEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orderWithPrismaStatusEqualsUniqueParam) orderModel()  {}
func (p orderWithPrismaStatusEqualsUniqueParam) statusField() {}

func (orderWithPrismaStatusEqualsUniqueParam) unique() {}
func (orderWithPrismaStatusEqualsUniqueParam) equals() {}

type wishlistActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var wishlistOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "productId"},
}

type WishlistRelationWith interface {
	getQuery() builder.Query
	with()
	wishlistRelation()
}

type WishlistWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
}

type wishlistDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistDefaultParam) field() builder.Field {
	return p.data
}

func (p wishlistDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistDefaultParam) wishlistModel() {}

type WishlistOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
}

type wishlistOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistOrderByParam) field() builder.Field {
	return p.data
}

func (p wishlistOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistOrderByParam) wishlistModel() {}

type WishlistCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	isCursor()
}

type wishlistCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistCursorParam) field() builder.Field {
	return p.data
}

func (p wishlistCursorParam) isCursor() {}

func (p wishlistCursorParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistCursorParam) wishlistModel() {}

type WishlistParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	wishlistModel()
}

type wishlistParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistParamUnique) wishlistModel() {}

func (wishlistParamUnique) unique() {}

func (p wishlistParamUnique) field() builder.Field {
	return p.data
}

func (p wishlistParamUnique) getQuery() builder.Query {
	return p.query
}

type WishlistEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	wishlistModel()
}

type wishlistEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistEqualsParam) wishlistModel() {}

func (wishlistEqualsParam) equals() {}

func (p wishlistEqualsParam) field() builder.Field {
	return p.data
}

func (p wishlistEqualsParam) getQuery() builder.Query {
	return p.query
}

type WishlistEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	wishlistModel()
}

type wishlistEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistEqualsUniqueParam) wishlistModel() {}

func (wishlistEqualsUniqueParam) unique() {}
func (wishlistEqualsUniqueParam) equals() {}

func (p wishlistEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p wishlistEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type WishlistSetParam interface {
	field() builder.Field
	settable()
	wishlistModel()
}

type wishlistSetParam struct {
	data builder.Field
}

func (wishlistSetParam) settable() {}

func (p wishlistSetParam) field() builder.Field {
	return p.data
}

func (p wishlistSetParam) wishlistModel() {}

type WishlistWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	wishlistModel()
	idField()
}

type WishlistWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	idField()
}

type wishlistWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaIDSetParam) wishlistModel() {}

func (p wishlistWithPrismaIDSetParam) idField() {}

type WishlistWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	idField()
}

type wishlistWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaIDEqualsParam) wishlistModel() {}

func (p wishlistWithPrismaIDEqualsParam) idField() {}

func (wishlistWithPrismaIDSetParam) settable()  {}
func (wishlistWithPrismaIDEqualsParam) equals() {}

type wishlistWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaIDEqualsUniqueParam) wishlistModel() {}
func (p wishlistWithPrismaIDEqualsUniqueParam) idField()       {}

func (wishlistWithPrismaIDEqualsUniqueParam) unique() {}
func (wishlistWithPrismaIDEqualsUniqueParam) equals() {}

type WishlistWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	wishlistModel()
	userField()
}

type WishlistWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	userField()
}

type wishlistWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaUserSetParam) wishlistModel() {}

func (p wishlistWithPrismaUserSetParam) userField() {}

type WishlistWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	userField()
}

type wishlistWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaUserEqualsParam) wishlistModel() {}

func (p wishlistWithPrismaUserEqualsParam) userField() {}

func (wishlistWithPrismaUserSetParam) settable()  {}
func (wishlistWithPrismaUserEqualsParam) equals() {}

type wishlistWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaUserEqualsUniqueParam) wishlistModel() {}
func (p wishlistWithPrismaUserEqualsUniqueParam) userField()     {}

func (wishlistWithPrismaUserEqualsUniqueParam) unique() {}
func (wishlistWithPrismaUserEqualsUniqueParam) equals() {}

type WishlistWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	wishlistModel()
	userIDField()
}

type WishlistWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	userIDField()
}

type wishlistWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaUserIDSetParam) wishlistModel() {}

func (p wishlistWithPrismaUserIDSetParam) userIDField() {}

type WishlistWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	userIDField()
}

type wishlistWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaUserIDEqualsParam) wishlistModel() {}

func (p wishlistWithPrismaUserIDEqualsParam) userIDField() {}

func (wishlistWithPrismaUserIDSetParam) settable()  {}
func (wishlistWithPrismaUserIDEqualsParam) equals() {}

type wishlistWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaUserIDEqualsUniqueParam) wishlistModel() {}
func (p wishlistWithPrismaUserIDEqualsUniqueParam) userIDField()   {}

func (wishlistWithPrismaUserIDEqualsUniqueParam) unique() {}
func (wishlistWithPrismaUserIDEqualsUniqueParam) equals() {}

type WishlistWithPrismaProductEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	wishlistModel()
	productField()
}

type WishlistWithPrismaProductSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	productField()
}

type wishlistWithPrismaProductSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaProductSetParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaProductSetParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaProductSetParam) wishlistModel() {}

func (p wishlistWithPrismaProductSetParam) productField() {}

type WishlistWithPrismaProductWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	productField()
}

type wishlistWithPrismaProductEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaProductEqualsParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaProductEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaProductEqualsParam) wishlistModel() {}

func (p wishlistWithPrismaProductEqualsParam) productField() {}

func (wishlistWithPrismaProductSetParam) settable()  {}
func (wishlistWithPrismaProductEqualsParam) equals() {}

type wishlistWithPrismaProductEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaProductEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaProductEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaProductEqualsUniqueParam) wishlistModel() {}
func (p wishlistWithPrismaProductEqualsUniqueParam) productField()  {}

func (wishlistWithPrismaProductEqualsUniqueParam) unique() {}
func (wishlistWithPrismaProductEqualsUniqueParam) equals() {}

type WishlistWithPrismaProductIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	wishlistModel()
	productIDField()
}

type WishlistWithPrismaProductIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	productIDField()
}

type wishlistWithPrismaProductIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaProductIDSetParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaProductIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaProductIDSetParam) wishlistModel() {}

func (p wishlistWithPrismaProductIDSetParam) productIDField() {}

type WishlistWithPrismaProductIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	wishlistModel()
	productIDField()
}

type wishlistWithPrismaProductIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaProductIDEqualsParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaProductIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaProductIDEqualsParam) wishlistModel() {}

func (p wishlistWithPrismaProductIDEqualsParam) productIDField() {}

func (wishlistWithPrismaProductIDSetParam) settable()  {}
func (wishlistWithPrismaProductIDEqualsParam) equals() {}

type wishlistWithPrismaProductIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p wishlistWithPrismaProductIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p wishlistWithPrismaProductIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p wishlistWithPrismaProductIDEqualsUniqueParam) wishlistModel()  {}
func (p wishlistWithPrismaProductIDEqualsUniqueParam) productIDField() {}

func (wishlistWithPrismaProductIDEqualsUniqueParam) unique() {}
func (wishlistWithPrismaProductIDEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_firstName UserWithPrismaFirstNameSetParam,
	_otherName UserWithPrismaOtherNameSetParam,
	_email UserWithPrismaEmailSetParam,
	_password UserWithPrismaPasswordSetParam,
	_salt UserWithPrismaSaltSetParam,
	_role UserWithPrismaRoleSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _firstName.field())
	fields = append(fields, _otherName.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())
	fields = append(fields, _salt.field())
	fields = append(fields, _role.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single vendor.
func (r vendorActions) CreateOne(
	_user VendorWithPrismaUserSetParam,
	_businessName VendorWithPrismaBusinessNameSetParam,
	_taxPin VendorWithPrismaTaxPinSetParam,

	optional ...VendorSetParam,
) vendorCreateOne {
	var v vendorCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Vendor"
	v.query.Outputs = vendorOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _businessName.field())
	fields = append(fields, _taxPin.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r vendorCreateOne) With(params ...VendorRelationWith) vendorCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type vendorCreateOne struct {
	query builder.Query
}

func (p vendorCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p vendorCreateOne) vendorModel() {}

func (r vendorCreateOne) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorCreateOne) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single product.
func (r productActions) CreateOne(
	_vendor ProductWithPrismaVendorSetParam,
	_name ProductWithPrismaNameSetParam,
	_price ProductWithPrismaPriceSetParam,
	_category ProductWithPrismaCategorySetParam,
	_imageURL ProductWithPrismaImageURLSetParam,

	optional ...ProductSetParam,
) productCreateOne {
	var v productCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Product"
	v.query.Outputs = productOutput

	var fields []builder.Field

	fields = append(fields, _vendor.field())
	fields = append(fields, _name.field())
	fields = append(fields, _price.field())
	fields = append(fields, _category.field())
	fields = append(fields, _imageURL.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r productCreateOne) With(params ...ProductRelationWith) productCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type productCreateOne struct {
	query builder.Query
}

func (p productCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p productCreateOne) productModel() {}

func (r productCreateOne) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productCreateOne) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single order.
func (r orderActions) CreateOne(
	_user OrderWithPrismaUserSetParam,
	_product OrderWithPrismaProductSetParam,
	_quantity OrderWithPrismaQuantitySetParam,
	_status OrderWithPrismaStatusSetParam,

	optional ...OrderSetParam,
) orderCreateOne {
	var v orderCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Order"
	v.query.Outputs = orderOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _product.field())
	fields = append(fields, _quantity.field())
	fields = append(fields, _status.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r orderCreateOne) With(params ...OrderRelationWith) orderCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type orderCreateOne struct {
	query builder.Query
}

func (p orderCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p orderCreateOne) orderModel() {}

func (r orderCreateOne) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderCreateOne) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single wishlist.
func (r wishlistActions) CreateOne(
	_user WishlistWithPrismaUserSetParam,
	_product WishlistWithPrismaProductSetParam,

	optional ...WishlistSetParam,
) wishlistCreateOne {
	var v wishlistCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Wishlist"
	v.query.Outputs = wishlistOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _product.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r wishlistCreateOne) With(params ...WishlistRelationWith) wishlistCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type wishlistCreateOne struct {
	query builder.Query
}

func (p wishlistCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p wishlistCreateOne) wishlistModel() {}

func (r wishlistCreateOne) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistCreateOne) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userToVendorFindUnique struct {
	query builder.Query
}

func (r userToVendorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToVendorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVendorFindUnique) with()         {}
func (r userToVendorFindUnique) userModel()    {}
func (r userToVendorFindUnique) userRelation() {}

func (r userToVendorFindUnique) With(params ...VendorRelationWith) userToVendorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToVendorFindUnique) Select(params ...userPrismaFields) userToVendorFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVendorFindUnique) Omit(params ...userPrismaFields) userToVendorFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVendorFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToVendorFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToVendorFindUnique) Update(params ...UserSetParam) userToVendorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToVendorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToVendorUpdateUnique struct {
	query builder.Query
}

func (r userToVendorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVendorUpdateUnique) userModel() {}

func (r userToVendorUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVendorUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToVendorFindUnique) Delete() userToVendorDeleteUnique {
	var v userToVendorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToVendorDeleteUnique struct {
	query builder.Query
}

func (r userToVendorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToVendorDeleteUnique) userModel() {}

func (r userToVendorDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVendorDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToVendorFindFirst struct {
	query builder.Query
}

func (r userToVendorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToVendorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVendorFindFirst) with()         {}
func (r userToVendorFindFirst) userModel()    {}
func (r userToVendorFindFirst) userRelation() {}

func (r userToVendorFindFirst) With(params ...VendorRelationWith) userToVendorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToVendorFindFirst) Select(params ...userPrismaFields) userToVendorFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVendorFindFirst) Omit(params ...userPrismaFields) userToVendorFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVendorFindFirst) OrderBy(params ...VendorOrderByParam) userToVendorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToVendorFindFirst) Skip(count int) userToVendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToVendorFindFirst) Take(count int) userToVendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToVendorFindFirst) Cursor(cursor UserCursorParam) userToVendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToVendorFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToVendorFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToVendorFindMany struct {
	query builder.Query
}

func (r userToVendorFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToVendorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVendorFindMany) with()         {}
func (r userToVendorFindMany) userModel()    {}
func (r userToVendorFindMany) userRelation() {}

func (r userToVendorFindMany) With(params ...VendorRelationWith) userToVendorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToVendorFindMany) Select(params ...userPrismaFields) userToVendorFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVendorFindMany) Omit(params ...userPrismaFields) userToVendorFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVendorFindMany) OrderBy(params ...VendorOrderByParam) userToVendorFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToVendorFindMany) Skip(count int) userToVendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToVendorFindMany) Take(count int) userToVendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToVendorFindMany) Cursor(cursor UserCursorParam) userToVendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToVendorFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToVendorFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToVendorFindMany) Update(params ...UserSetParam) userToVendorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToVendorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToVendorUpdateMany struct {
	query builder.Query
}

func (r userToVendorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVendorUpdateMany) userModel() {}

func (r userToVendorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVendorUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToVendorFindMany) Delete() userToVendorDeleteMany {
	var v userToVendorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToVendorDeleteMany struct {
	query builder.Query
}

func (r userToVendorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToVendorDeleteMany) userModel() {}

func (r userToVendorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVendorDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToOrderFindUnique struct {
	query builder.Query
}

func (r userToOrderFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToOrderFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOrderFindUnique) with()         {}
func (r userToOrderFindUnique) userModel()    {}
func (r userToOrderFindUnique) userRelation() {}

func (r userToOrderFindUnique) With(params ...OrderRelationWith) userToOrderFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToOrderFindUnique) Select(params ...userPrismaFields) userToOrderFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOrderFindUnique) Omit(params ...userPrismaFields) userToOrderFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOrderFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToOrderFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToOrderFindUnique) Update(params ...UserSetParam) userToOrderUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToOrderUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToOrderUpdateUnique struct {
	query builder.Query
}

func (r userToOrderUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOrderUpdateUnique) userModel() {}

func (r userToOrderUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOrderUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToOrderFindUnique) Delete() userToOrderDeleteUnique {
	var v userToOrderDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToOrderDeleteUnique struct {
	query builder.Query
}

func (r userToOrderDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToOrderDeleteUnique) userModel() {}

func (r userToOrderDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOrderDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToOrderFindFirst struct {
	query builder.Query
}

func (r userToOrderFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToOrderFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOrderFindFirst) with()         {}
func (r userToOrderFindFirst) userModel()    {}
func (r userToOrderFindFirst) userRelation() {}

func (r userToOrderFindFirst) With(params ...OrderRelationWith) userToOrderFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToOrderFindFirst) Select(params ...userPrismaFields) userToOrderFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOrderFindFirst) Omit(params ...userPrismaFields) userToOrderFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOrderFindFirst) OrderBy(params ...OrderOrderByParam) userToOrderFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToOrderFindFirst) Skip(count int) userToOrderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToOrderFindFirst) Take(count int) userToOrderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToOrderFindFirst) Cursor(cursor UserCursorParam) userToOrderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToOrderFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToOrderFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToOrderFindMany struct {
	query builder.Query
}

func (r userToOrderFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToOrderFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOrderFindMany) with()         {}
func (r userToOrderFindMany) userModel()    {}
func (r userToOrderFindMany) userRelation() {}

func (r userToOrderFindMany) With(params ...OrderRelationWith) userToOrderFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToOrderFindMany) Select(params ...userPrismaFields) userToOrderFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOrderFindMany) Omit(params ...userPrismaFields) userToOrderFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOrderFindMany) OrderBy(params ...OrderOrderByParam) userToOrderFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToOrderFindMany) Skip(count int) userToOrderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToOrderFindMany) Take(count int) userToOrderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToOrderFindMany) Cursor(cursor UserCursorParam) userToOrderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToOrderFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToOrderFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToOrderFindMany) Update(params ...UserSetParam) userToOrderUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToOrderUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToOrderUpdateMany struct {
	query builder.Query
}

func (r userToOrderUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOrderUpdateMany) userModel() {}

func (r userToOrderUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOrderUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToOrderFindMany) Delete() userToOrderDeleteMany {
	var v userToOrderDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToOrderDeleteMany struct {
	query builder.Query
}

func (r userToOrderDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToOrderDeleteMany) userModel() {}

func (r userToOrderDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOrderDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToWishlistFindUnique struct {
	query builder.Query
}

func (r userToWishlistFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToWishlistFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWishlistFindUnique) with()         {}
func (r userToWishlistFindUnique) userModel()    {}
func (r userToWishlistFindUnique) userRelation() {}

func (r userToWishlistFindUnique) With(params ...WishlistRelationWith) userToWishlistFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToWishlistFindUnique) Select(params ...userPrismaFields) userToWishlistFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWishlistFindUnique) Omit(params ...userPrismaFields) userToWishlistFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWishlistFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToWishlistFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToWishlistFindUnique) Update(params ...UserSetParam) userToWishlistUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToWishlistUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToWishlistUpdateUnique struct {
	query builder.Query
}

func (r userToWishlistUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWishlistUpdateUnique) userModel() {}

func (r userToWishlistUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWishlistUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToWishlistFindUnique) Delete() userToWishlistDeleteUnique {
	var v userToWishlistDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToWishlistDeleteUnique struct {
	query builder.Query
}

func (r userToWishlistDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToWishlistDeleteUnique) userModel() {}

func (r userToWishlistDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWishlistDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToWishlistFindFirst struct {
	query builder.Query
}

func (r userToWishlistFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToWishlistFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWishlistFindFirst) with()         {}
func (r userToWishlistFindFirst) userModel()    {}
func (r userToWishlistFindFirst) userRelation() {}

func (r userToWishlistFindFirst) With(params ...WishlistRelationWith) userToWishlistFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToWishlistFindFirst) Select(params ...userPrismaFields) userToWishlistFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWishlistFindFirst) Omit(params ...userPrismaFields) userToWishlistFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWishlistFindFirst) OrderBy(params ...WishlistOrderByParam) userToWishlistFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToWishlistFindFirst) Skip(count int) userToWishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToWishlistFindFirst) Take(count int) userToWishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToWishlistFindFirst) Cursor(cursor UserCursorParam) userToWishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToWishlistFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToWishlistFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToWishlistFindMany struct {
	query builder.Query
}

func (r userToWishlistFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToWishlistFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWishlistFindMany) with()         {}
func (r userToWishlistFindMany) userModel()    {}
func (r userToWishlistFindMany) userRelation() {}

func (r userToWishlistFindMany) With(params ...WishlistRelationWith) userToWishlistFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToWishlistFindMany) Select(params ...userPrismaFields) userToWishlistFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWishlistFindMany) Omit(params ...userPrismaFields) userToWishlistFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWishlistFindMany) OrderBy(params ...WishlistOrderByParam) userToWishlistFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToWishlistFindMany) Skip(count int) userToWishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToWishlistFindMany) Take(count int) userToWishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToWishlistFindMany) Cursor(cursor UserCursorParam) userToWishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToWishlistFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToWishlistFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToWishlistFindMany) Update(params ...UserSetParam) userToWishlistUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToWishlistUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToWishlistUpdateMany struct {
	query builder.Query
}

func (r userToWishlistUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWishlistUpdateMany) userModel() {}

func (r userToWishlistUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWishlistUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToWishlistFindMany) Delete() userToWishlistDeleteMany {
	var v userToWishlistDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToWishlistDeleteMany struct {
	query builder.Query
}

func (r userToWishlistDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToWishlistDeleteMany) userModel() {}

func (r userToWishlistDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWishlistDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Select(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Omit(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) Select(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) Omit(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) Select(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) Omit(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type vendorToUserFindUnique struct {
	query builder.Query
}

func (r vendorToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r vendorToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToUserFindUnique) with()           {}
func (r vendorToUserFindUnique) vendorModel()    {}
func (r vendorToUserFindUnique) vendorRelation() {}

func (r vendorToUserFindUnique) With(params ...UserRelationWith) vendorToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorToUserFindUnique) Select(params ...vendorPrismaFields) vendorToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToUserFindUnique) Omit(params ...vendorPrismaFields) vendorToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToUserFindUnique) Exec(ctx context.Context) (
	*VendorModel,
	error,
) {
	var v *VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerVendor,
	error,
) {
	var v *InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorToUserFindUnique) Update(params ...VendorSetParam) vendorToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Vendor"

	var v vendorToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type vendorToUserUpdateUnique struct {
	query builder.Query
}

func (r vendorToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToUserUpdateUnique) vendorModel() {}

func (r vendorToUserUpdateUnique) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToUserUpdateUnique) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r vendorToUserFindUnique) Delete() vendorToUserDeleteUnique {
	var v vendorToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Vendor"

	return v
}

type vendorToUserDeleteUnique struct {
	query builder.Query
}

func (r vendorToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p vendorToUserDeleteUnique) vendorModel() {}

func (r vendorToUserDeleteUnique) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToUserDeleteUnique) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type vendorToUserFindFirst struct {
	query builder.Query
}

func (r vendorToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r vendorToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToUserFindFirst) with()           {}
func (r vendorToUserFindFirst) vendorModel()    {}
func (r vendorToUserFindFirst) vendorRelation() {}

func (r vendorToUserFindFirst) With(params ...UserRelationWith) vendorToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorToUserFindFirst) Select(params ...vendorPrismaFields) vendorToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToUserFindFirst) Omit(params ...vendorPrismaFields) vendorToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToUserFindFirst) OrderBy(params ...UserOrderByParam) vendorToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r vendorToUserFindFirst) Skip(count int) vendorToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r vendorToUserFindFirst) Take(count int) vendorToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r vendorToUserFindFirst) Cursor(cursor VendorCursorParam) vendorToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r vendorToUserFindFirst) Exec(ctx context.Context) (
	*VendorModel,
	error,
) {
	var v *VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerVendor,
	error,
) {
	var v *InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type vendorToUserFindMany struct {
	query builder.Query
}

func (r vendorToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r vendorToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToUserFindMany) with()           {}
func (r vendorToUserFindMany) vendorModel()    {}
func (r vendorToUserFindMany) vendorRelation() {}

func (r vendorToUserFindMany) With(params ...UserRelationWith) vendorToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorToUserFindMany) Select(params ...vendorPrismaFields) vendorToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToUserFindMany) Omit(params ...vendorPrismaFields) vendorToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToUserFindMany) OrderBy(params ...UserOrderByParam) vendorToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r vendorToUserFindMany) Skip(count int) vendorToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r vendorToUserFindMany) Take(count int) vendorToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r vendorToUserFindMany) Cursor(cursor VendorCursorParam) vendorToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r vendorToUserFindMany) Exec(ctx context.Context) (
	[]VendorModel,
	error,
) {
	var v []VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r vendorToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerVendor,
	error,
) {
	var v []InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r vendorToUserFindMany) Update(params ...VendorSetParam) vendorToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Vendor"

	r.query.Outputs = countOutput

	var v vendorToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type vendorToUserUpdateMany struct {
	query builder.Query
}

func (r vendorToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToUserUpdateMany) vendorModel() {}

func (r vendorToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToUserUpdateMany) Tx() VendorManyTxResult {
	v := newVendorManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r vendorToUserFindMany) Delete() vendorToUserDeleteMany {
	var v vendorToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Vendor"

	v.query.Outputs = countOutput

	return v
}

type vendorToUserDeleteMany struct {
	query builder.Query
}

func (r vendorToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p vendorToUserDeleteMany) vendorModel() {}

func (r vendorToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToUserDeleteMany) Tx() VendorManyTxResult {
	v := newVendorManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type vendorToProductFindUnique struct {
	query builder.Query
}

func (r vendorToProductFindUnique) getQuery() builder.Query {
	return r.query
}

func (r vendorToProductFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToProductFindUnique) with()           {}
func (r vendorToProductFindUnique) vendorModel()    {}
func (r vendorToProductFindUnique) vendorRelation() {}

func (r vendorToProductFindUnique) With(params ...ProductRelationWith) vendorToProductFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorToProductFindUnique) Select(params ...vendorPrismaFields) vendorToProductFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToProductFindUnique) Omit(params ...vendorPrismaFields) vendorToProductFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToProductFindUnique) Exec(ctx context.Context) (
	*VendorModel,
	error,
) {
	var v *VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorToProductFindUnique) ExecInner(ctx context.Context) (
	*InnerVendor,
	error,
) {
	var v *InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorToProductFindUnique) Update(params ...VendorSetParam) vendorToProductUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Vendor"

	var v vendorToProductUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type vendorToProductUpdateUnique struct {
	query builder.Query
}

func (r vendorToProductUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToProductUpdateUnique) vendorModel() {}

func (r vendorToProductUpdateUnique) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToProductUpdateUnique) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r vendorToProductFindUnique) Delete() vendorToProductDeleteUnique {
	var v vendorToProductDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Vendor"

	return v
}

type vendorToProductDeleteUnique struct {
	query builder.Query
}

func (r vendorToProductDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p vendorToProductDeleteUnique) vendorModel() {}

func (r vendorToProductDeleteUnique) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToProductDeleteUnique) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type vendorToProductFindFirst struct {
	query builder.Query
}

func (r vendorToProductFindFirst) getQuery() builder.Query {
	return r.query
}

func (r vendorToProductFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToProductFindFirst) with()           {}
func (r vendorToProductFindFirst) vendorModel()    {}
func (r vendorToProductFindFirst) vendorRelation() {}

func (r vendorToProductFindFirst) With(params ...ProductRelationWith) vendorToProductFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorToProductFindFirst) Select(params ...vendorPrismaFields) vendorToProductFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToProductFindFirst) Omit(params ...vendorPrismaFields) vendorToProductFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToProductFindFirst) OrderBy(params ...ProductOrderByParam) vendorToProductFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r vendorToProductFindFirst) Skip(count int) vendorToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r vendorToProductFindFirst) Take(count int) vendorToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r vendorToProductFindFirst) Cursor(cursor VendorCursorParam) vendorToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r vendorToProductFindFirst) Exec(ctx context.Context) (
	*VendorModel,
	error,
) {
	var v *VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorToProductFindFirst) ExecInner(ctx context.Context) (
	*InnerVendor,
	error,
) {
	var v *InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type vendorToProductFindMany struct {
	query builder.Query
}

func (r vendorToProductFindMany) getQuery() builder.Query {
	return r.query
}

func (r vendorToProductFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToProductFindMany) with()           {}
func (r vendorToProductFindMany) vendorModel()    {}
func (r vendorToProductFindMany) vendorRelation() {}

func (r vendorToProductFindMany) With(params ...ProductRelationWith) vendorToProductFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorToProductFindMany) Select(params ...vendorPrismaFields) vendorToProductFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToProductFindMany) Omit(params ...vendorPrismaFields) vendorToProductFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorToProductFindMany) OrderBy(params ...ProductOrderByParam) vendorToProductFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r vendorToProductFindMany) Skip(count int) vendorToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r vendorToProductFindMany) Take(count int) vendorToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r vendorToProductFindMany) Cursor(cursor VendorCursorParam) vendorToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r vendorToProductFindMany) Exec(ctx context.Context) (
	[]VendorModel,
	error,
) {
	var v []VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r vendorToProductFindMany) ExecInner(ctx context.Context) (
	[]InnerVendor,
	error,
) {
	var v []InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r vendorToProductFindMany) Update(params ...VendorSetParam) vendorToProductUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Vendor"

	r.query.Outputs = countOutput

	var v vendorToProductUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type vendorToProductUpdateMany struct {
	query builder.Query
}

func (r vendorToProductUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorToProductUpdateMany) vendorModel() {}

func (r vendorToProductUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToProductUpdateMany) Tx() VendorManyTxResult {
	v := newVendorManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r vendorToProductFindMany) Delete() vendorToProductDeleteMany {
	var v vendorToProductDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Vendor"

	v.query.Outputs = countOutput

	return v
}

type vendorToProductDeleteMany struct {
	query builder.Query
}

func (r vendorToProductDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p vendorToProductDeleteMany) vendorModel() {}

func (r vendorToProductDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorToProductDeleteMany) Tx() VendorManyTxResult {
	v := newVendorManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type vendorFindUnique struct {
	query builder.Query
}

func (r vendorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r vendorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorFindUnique) with()           {}
func (r vendorFindUnique) vendorModel()    {}
func (r vendorFindUnique) vendorRelation() {}

func (r vendorActions) FindUnique(
	params VendorEqualsUniqueWhereParam,
) vendorFindUnique {
	var v vendorFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Vendor"
	v.query.Outputs = vendorOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r vendorFindUnique) With(params ...VendorRelationWith) vendorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorFindUnique) Select(params ...vendorPrismaFields) vendorFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorFindUnique) Omit(params ...vendorPrismaFields) vendorFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorFindUnique) Exec(ctx context.Context) (
	*VendorModel,
	error,
) {
	var v *VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorFindUnique) ExecInner(ctx context.Context) (
	*InnerVendor,
	error,
) {
	var v *InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorFindUnique) Update(params ...VendorSetParam) vendorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Vendor"

	var v vendorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type vendorUpdateUnique struct {
	query builder.Query
}

func (r vendorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorUpdateUnique) vendorModel() {}

func (r vendorUpdateUnique) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorUpdateUnique) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r vendorFindUnique) Delete() vendorDeleteUnique {
	var v vendorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Vendor"

	return v
}

type vendorDeleteUnique struct {
	query builder.Query
}

func (r vendorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p vendorDeleteUnique) vendorModel() {}

func (r vendorDeleteUnique) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorDeleteUnique) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type vendorFindFirst struct {
	query builder.Query
}

func (r vendorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r vendorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorFindFirst) with()           {}
func (r vendorFindFirst) vendorModel()    {}
func (r vendorFindFirst) vendorRelation() {}

func (r vendorActions) FindFirst(
	params ...VendorWhereParam,
) vendorFindFirst {
	var v vendorFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Vendor"
	v.query.Outputs = vendorOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r vendorFindFirst) With(params ...VendorRelationWith) vendorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorFindFirst) Select(params ...vendorPrismaFields) vendorFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorFindFirst) Omit(params ...vendorPrismaFields) vendorFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorFindFirst) OrderBy(params ...VendorOrderByParam) vendorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r vendorFindFirst) Skip(count int) vendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r vendorFindFirst) Take(count int) vendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r vendorFindFirst) Cursor(cursor VendorCursorParam) vendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r vendorFindFirst) Exec(ctx context.Context) (
	*VendorModel,
	error,
) {
	var v *VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r vendorFindFirst) ExecInner(ctx context.Context) (
	*InnerVendor,
	error,
) {
	var v *InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type vendorFindMany struct {
	query builder.Query
}

func (r vendorFindMany) getQuery() builder.Query {
	return r.query
}

func (r vendorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorFindMany) with()           {}
func (r vendorFindMany) vendorModel()    {}
func (r vendorFindMany) vendorRelation() {}

func (r vendorActions) FindMany(
	params ...VendorWhereParam,
) vendorFindMany {
	var v vendorFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Vendor"
	v.query.Outputs = vendorOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r vendorFindMany) With(params ...VendorRelationWith) vendorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r vendorFindMany) Select(params ...vendorPrismaFields) vendorFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorFindMany) Omit(params ...vendorPrismaFields) vendorFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range vendorOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r vendorFindMany) OrderBy(params ...VendorOrderByParam) vendorFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r vendorFindMany) Skip(count int) vendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r vendorFindMany) Take(count int) vendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r vendorFindMany) Cursor(cursor VendorCursorParam) vendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r vendorFindMany) Exec(ctx context.Context) (
	[]VendorModel,
	error,
) {
	var v []VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r vendorFindMany) ExecInner(ctx context.Context) (
	[]InnerVendor,
	error,
) {
	var v []InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r vendorFindMany) Update(params ...VendorSetParam) vendorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Vendor"

	r.query.Outputs = countOutput

	var v vendorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type vendorUpdateMany struct {
	query builder.Query
}

func (r vendorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorUpdateMany) vendorModel() {}

func (r vendorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorUpdateMany) Tx() VendorManyTxResult {
	v := newVendorManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r vendorFindMany) Delete() vendorDeleteMany {
	var v vendorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Vendor"

	v.query.Outputs = countOutput

	return v
}

type vendorDeleteMany struct {
	query builder.Query
}

func (r vendorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p vendorDeleteMany) vendorModel() {}

func (r vendorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorDeleteMany) Tx() VendorManyTxResult {
	v := newVendorManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productToVendorFindUnique struct {
	query builder.Query
}

func (r productToVendorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r productToVendorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productToVendorFindUnique) with()            {}
func (r productToVendorFindUnique) productModel()    {}
func (r productToVendorFindUnique) productRelation() {}

func (r productToVendorFindUnique) With(params ...VendorRelationWith) productToVendorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToVendorFindUnique) Select(params ...productPrismaFields) productToVendorFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToVendorFindUnique) Omit(params ...productPrismaFields) productToVendorFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToVendorFindUnique) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToVendorFindUnique) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToVendorFindUnique) Update(params ...ProductSetParam) productToVendorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Product"

	var v productToVendorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productToVendorUpdateUnique struct {
	query builder.Query
}

func (r productToVendorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productToVendorUpdateUnique) productModel() {}

func (r productToVendorUpdateUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToVendorUpdateUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productToVendorFindUnique) Delete() productToVendorDeleteUnique {
	var v productToVendorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Product"

	return v
}

type productToVendorDeleteUnique struct {
	query builder.Query
}

func (r productToVendorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p productToVendorDeleteUnique) productModel() {}

func (r productToVendorDeleteUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToVendorDeleteUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productToVendorFindFirst struct {
	query builder.Query
}

func (r productToVendorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r productToVendorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r productToVendorFindFirst) with()            {}
func (r productToVendorFindFirst) productModel()    {}
func (r productToVendorFindFirst) productRelation() {}

func (r productToVendorFindFirst) With(params ...VendorRelationWith) productToVendorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToVendorFindFirst) Select(params ...productPrismaFields) productToVendorFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToVendorFindFirst) Omit(params ...productPrismaFields) productToVendorFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToVendorFindFirst) OrderBy(params ...VendorOrderByParam) productToVendorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productToVendorFindFirst) Skip(count int) productToVendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productToVendorFindFirst) Take(count int) productToVendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productToVendorFindFirst) Cursor(cursor ProductCursorParam) productToVendorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productToVendorFindFirst) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToVendorFindFirst) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type productToVendorFindMany struct {
	query builder.Query
}

func (r productToVendorFindMany) getQuery() builder.Query {
	return r.query
}

func (r productToVendorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productToVendorFindMany) with()            {}
func (r productToVendorFindMany) productModel()    {}
func (r productToVendorFindMany) productRelation() {}

func (r productToVendorFindMany) With(params ...VendorRelationWith) productToVendorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToVendorFindMany) Select(params ...productPrismaFields) productToVendorFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToVendorFindMany) Omit(params ...productPrismaFields) productToVendorFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToVendorFindMany) OrderBy(params ...VendorOrderByParam) productToVendorFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productToVendorFindMany) Skip(count int) productToVendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productToVendorFindMany) Take(count int) productToVendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productToVendorFindMany) Cursor(cursor ProductCursorParam) productToVendorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productToVendorFindMany) Exec(ctx context.Context) (
	[]ProductModel,
	error,
) {
	var v []ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productToVendorFindMany) ExecInner(ctx context.Context) (
	[]InnerProduct,
	error,
) {
	var v []InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productToVendorFindMany) Update(params ...ProductSetParam) productToVendorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Product"

	r.query.Outputs = countOutput

	var v productToVendorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productToVendorUpdateMany struct {
	query builder.Query
}

func (r productToVendorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productToVendorUpdateMany) productModel() {}

func (r productToVendorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToVendorUpdateMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productToVendorFindMany) Delete() productToVendorDeleteMany {
	var v productToVendorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Product"

	v.query.Outputs = countOutput

	return v
}

type productToVendorDeleteMany struct {
	query builder.Query
}

func (r productToVendorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p productToVendorDeleteMany) productModel() {}

func (r productToVendorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToVendorDeleteMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productToOrderFindUnique struct {
	query builder.Query
}

func (r productToOrderFindUnique) getQuery() builder.Query {
	return r.query
}

func (r productToOrderFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productToOrderFindUnique) with()            {}
func (r productToOrderFindUnique) productModel()    {}
func (r productToOrderFindUnique) productRelation() {}

func (r productToOrderFindUnique) With(params ...OrderRelationWith) productToOrderFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToOrderFindUnique) Select(params ...productPrismaFields) productToOrderFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToOrderFindUnique) Omit(params ...productPrismaFields) productToOrderFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToOrderFindUnique) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToOrderFindUnique) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToOrderFindUnique) Update(params ...ProductSetParam) productToOrderUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Product"

	var v productToOrderUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productToOrderUpdateUnique struct {
	query builder.Query
}

func (r productToOrderUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productToOrderUpdateUnique) productModel() {}

func (r productToOrderUpdateUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToOrderUpdateUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productToOrderFindUnique) Delete() productToOrderDeleteUnique {
	var v productToOrderDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Product"

	return v
}

type productToOrderDeleteUnique struct {
	query builder.Query
}

func (r productToOrderDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p productToOrderDeleteUnique) productModel() {}

func (r productToOrderDeleteUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToOrderDeleteUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productToOrderFindFirst struct {
	query builder.Query
}

func (r productToOrderFindFirst) getQuery() builder.Query {
	return r.query
}

func (r productToOrderFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r productToOrderFindFirst) with()            {}
func (r productToOrderFindFirst) productModel()    {}
func (r productToOrderFindFirst) productRelation() {}

func (r productToOrderFindFirst) With(params ...OrderRelationWith) productToOrderFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToOrderFindFirst) Select(params ...productPrismaFields) productToOrderFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToOrderFindFirst) Omit(params ...productPrismaFields) productToOrderFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToOrderFindFirst) OrderBy(params ...OrderOrderByParam) productToOrderFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productToOrderFindFirst) Skip(count int) productToOrderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productToOrderFindFirst) Take(count int) productToOrderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productToOrderFindFirst) Cursor(cursor ProductCursorParam) productToOrderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productToOrderFindFirst) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToOrderFindFirst) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type productToOrderFindMany struct {
	query builder.Query
}

func (r productToOrderFindMany) getQuery() builder.Query {
	return r.query
}

func (r productToOrderFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productToOrderFindMany) with()            {}
func (r productToOrderFindMany) productModel()    {}
func (r productToOrderFindMany) productRelation() {}

func (r productToOrderFindMany) With(params ...OrderRelationWith) productToOrderFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToOrderFindMany) Select(params ...productPrismaFields) productToOrderFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToOrderFindMany) Omit(params ...productPrismaFields) productToOrderFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToOrderFindMany) OrderBy(params ...OrderOrderByParam) productToOrderFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productToOrderFindMany) Skip(count int) productToOrderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productToOrderFindMany) Take(count int) productToOrderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productToOrderFindMany) Cursor(cursor ProductCursorParam) productToOrderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productToOrderFindMany) Exec(ctx context.Context) (
	[]ProductModel,
	error,
) {
	var v []ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productToOrderFindMany) ExecInner(ctx context.Context) (
	[]InnerProduct,
	error,
) {
	var v []InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productToOrderFindMany) Update(params ...ProductSetParam) productToOrderUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Product"

	r.query.Outputs = countOutput

	var v productToOrderUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productToOrderUpdateMany struct {
	query builder.Query
}

func (r productToOrderUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productToOrderUpdateMany) productModel() {}

func (r productToOrderUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToOrderUpdateMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productToOrderFindMany) Delete() productToOrderDeleteMany {
	var v productToOrderDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Product"

	v.query.Outputs = countOutput

	return v
}

type productToOrderDeleteMany struct {
	query builder.Query
}

func (r productToOrderDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p productToOrderDeleteMany) productModel() {}

func (r productToOrderDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToOrderDeleteMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productToWishlistFindUnique struct {
	query builder.Query
}

func (r productToWishlistFindUnique) getQuery() builder.Query {
	return r.query
}

func (r productToWishlistFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productToWishlistFindUnique) with()            {}
func (r productToWishlistFindUnique) productModel()    {}
func (r productToWishlistFindUnique) productRelation() {}

func (r productToWishlistFindUnique) With(params ...WishlistRelationWith) productToWishlistFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToWishlistFindUnique) Select(params ...productPrismaFields) productToWishlistFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToWishlistFindUnique) Omit(params ...productPrismaFields) productToWishlistFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToWishlistFindUnique) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToWishlistFindUnique) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToWishlistFindUnique) Update(params ...ProductSetParam) productToWishlistUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Product"

	var v productToWishlistUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productToWishlistUpdateUnique struct {
	query builder.Query
}

func (r productToWishlistUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productToWishlistUpdateUnique) productModel() {}

func (r productToWishlistUpdateUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToWishlistUpdateUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productToWishlistFindUnique) Delete() productToWishlistDeleteUnique {
	var v productToWishlistDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Product"

	return v
}

type productToWishlistDeleteUnique struct {
	query builder.Query
}

func (r productToWishlistDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p productToWishlistDeleteUnique) productModel() {}

func (r productToWishlistDeleteUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToWishlistDeleteUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productToWishlistFindFirst struct {
	query builder.Query
}

func (r productToWishlistFindFirst) getQuery() builder.Query {
	return r.query
}

func (r productToWishlistFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r productToWishlistFindFirst) with()            {}
func (r productToWishlistFindFirst) productModel()    {}
func (r productToWishlistFindFirst) productRelation() {}

func (r productToWishlistFindFirst) With(params ...WishlistRelationWith) productToWishlistFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToWishlistFindFirst) Select(params ...productPrismaFields) productToWishlistFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToWishlistFindFirst) Omit(params ...productPrismaFields) productToWishlistFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToWishlistFindFirst) OrderBy(params ...WishlistOrderByParam) productToWishlistFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productToWishlistFindFirst) Skip(count int) productToWishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productToWishlistFindFirst) Take(count int) productToWishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productToWishlistFindFirst) Cursor(cursor ProductCursorParam) productToWishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productToWishlistFindFirst) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productToWishlistFindFirst) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type productToWishlistFindMany struct {
	query builder.Query
}

func (r productToWishlistFindMany) getQuery() builder.Query {
	return r.query
}

func (r productToWishlistFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productToWishlistFindMany) with()            {}
func (r productToWishlistFindMany) productModel()    {}
func (r productToWishlistFindMany) productRelation() {}

func (r productToWishlistFindMany) With(params ...WishlistRelationWith) productToWishlistFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productToWishlistFindMany) Select(params ...productPrismaFields) productToWishlistFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productToWishlistFindMany) Omit(params ...productPrismaFields) productToWishlistFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productToWishlistFindMany) OrderBy(params ...WishlistOrderByParam) productToWishlistFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productToWishlistFindMany) Skip(count int) productToWishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productToWishlistFindMany) Take(count int) productToWishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productToWishlistFindMany) Cursor(cursor ProductCursorParam) productToWishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productToWishlistFindMany) Exec(ctx context.Context) (
	[]ProductModel,
	error,
) {
	var v []ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productToWishlistFindMany) ExecInner(ctx context.Context) (
	[]InnerProduct,
	error,
) {
	var v []InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productToWishlistFindMany) Update(params ...ProductSetParam) productToWishlistUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Product"

	r.query.Outputs = countOutput

	var v productToWishlistUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productToWishlistUpdateMany struct {
	query builder.Query
}

func (r productToWishlistUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productToWishlistUpdateMany) productModel() {}

func (r productToWishlistUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToWishlistUpdateMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productToWishlistFindMany) Delete() productToWishlistDeleteMany {
	var v productToWishlistDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Product"

	v.query.Outputs = countOutput

	return v
}

type productToWishlistDeleteMany struct {
	query builder.Query
}

func (r productToWishlistDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p productToWishlistDeleteMany) productModel() {}

func (r productToWishlistDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productToWishlistDeleteMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productFindUnique struct {
	query builder.Query
}

func (r productFindUnique) getQuery() builder.Query {
	return r.query
}

func (r productFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productFindUnique) with()            {}
func (r productFindUnique) productModel()    {}
func (r productFindUnique) productRelation() {}

func (r productActions) FindUnique(
	params ProductEqualsUniqueWhereParam,
) productFindUnique {
	var v productFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Product"
	v.query.Outputs = productOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r productFindUnique) With(params ...ProductRelationWith) productFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productFindUnique) Select(params ...productPrismaFields) productFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindUnique) Omit(params ...productPrismaFields) productFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindUnique) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productFindUnique) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productFindUnique) Update(params ...ProductSetParam) productUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Product"

	var v productUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productUpdateUnique struct {
	query builder.Query
}

func (r productUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productUpdateUnique) productModel() {}

func (r productUpdateUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productUpdateUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productFindUnique) Delete() productDeleteUnique {
	var v productDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Product"

	return v
}

type productDeleteUnique struct {
	query builder.Query
}

func (r productDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p productDeleteUnique) productModel() {}

func (r productDeleteUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productDeleteUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productFindFirst struct {
	query builder.Query
}

func (r productFindFirst) getQuery() builder.Query {
	return r.query
}

func (r productFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r productFindFirst) with()            {}
func (r productFindFirst) productModel()    {}
func (r productFindFirst) productRelation() {}

func (r productActions) FindFirst(
	params ...ProductWhereParam,
) productFindFirst {
	var v productFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Product"
	v.query.Outputs = productOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r productFindFirst) With(params ...ProductRelationWith) productFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productFindFirst) Select(params ...productPrismaFields) productFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindFirst) Omit(params ...productPrismaFields) productFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindFirst) OrderBy(params ...ProductOrderByParam) productFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productFindFirst) Skip(count int) productFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productFindFirst) Take(count int) productFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productFindFirst) Cursor(cursor ProductCursorParam) productFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productFindFirst) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productFindFirst) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type productFindMany struct {
	query builder.Query
}

func (r productFindMany) getQuery() builder.Query {
	return r.query
}

func (r productFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productFindMany) with()            {}
func (r productFindMany) productModel()    {}
func (r productFindMany) productRelation() {}

func (r productActions) FindMany(
	params ...ProductWhereParam,
) productFindMany {
	var v productFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Product"
	v.query.Outputs = productOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r productFindMany) With(params ...ProductRelationWith) productFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productFindMany) Select(params ...productPrismaFields) productFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindMany) Omit(params ...productPrismaFields) productFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindMany) OrderBy(params ...ProductOrderByParam) productFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productFindMany) Skip(count int) productFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productFindMany) Take(count int) productFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productFindMany) Cursor(cursor ProductCursorParam) productFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productFindMany) Exec(ctx context.Context) (
	[]ProductModel,
	error,
) {
	var v []ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productFindMany) ExecInner(ctx context.Context) (
	[]InnerProduct,
	error,
) {
	var v []InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productFindMany) Update(params ...ProductSetParam) productUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Product"

	r.query.Outputs = countOutput

	var v productUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productUpdateMany struct {
	query builder.Query
}

func (r productUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productUpdateMany) productModel() {}

func (r productUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productUpdateMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productFindMany) Delete() productDeleteMany {
	var v productDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Product"

	v.query.Outputs = countOutput

	return v
}

type productDeleteMany struct {
	query builder.Query
}

func (r productDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p productDeleteMany) productModel() {}

func (r productDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productDeleteMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orderToUserFindUnique struct {
	query builder.Query
}

func (r orderToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orderToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToUserFindUnique) with()          {}
func (r orderToUserFindUnique) orderModel()    {}
func (r orderToUserFindUnique) orderRelation() {}

func (r orderToUserFindUnique) With(params ...UserRelationWith) orderToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderToUserFindUnique) Select(params ...orderPrismaFields) orderToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToUserFindUnique) Omit(params ...orderPrismaFields) orderToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToUserFindUnique) Exec(ctx context.Context) (
	*OrderModel,
	error,
) {
	var v *OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerOrder,
	error,
) {
	var v *InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderToUserFindUnique) Update(params ...OrderSetParam) orderToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Order"

	var v orderToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orderToUserUpdateUnique struct {
	query builder.Query
}

func (r orderToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToUserUpdateUnique) orderModel() {}

func (r orderToUserUpdateUnique) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToUserUpdateUnique) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orderToUserFindUnique) Delete() orderToUserDeleteUnique {
	var v orderToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Order"

	return v
}

type orderToUserDeleteUnique struct {
	query builder.Query
}

func (r orderToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orderToUserDeleteUnique) orderModel() {}

func (r orderToUserDeleteUnique) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToUserDeleteUnique) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orderToUserFindFirst struct {
	query builder.Query
}

func (r orderToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orderToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToUserFindFirst) with()          {}
func (r orderToUserFindFirst) orderModel()    {}
func (r orderToUserFindFirst) orderRelation() {}

func (r orderToUserFindFirst) With(params ...UserRelationWith) orderToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderToUserFindFirst) Select(params ...orderPrismaFields) orderToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToUserFindFirst) Omit(params ...orderPrismaFields) orderToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToUserFindFirst) OrderBy(params ...UserOrderByParam) orderToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orderToUserFindFirst) Skip(count int) orderToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orderToUserFindFirst) Take(count int) orderToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orderToUserFindFirst) Cursor(cursor OrderCursorParam) orderToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orderToUserFindFirst) Exec(ctx context.Context) (
	*OrderModel,
	error,
) {
	var v *OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerOrder,
	error,
) {
	var v *InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orderToUserFindMany struct {
	query builder.Query
}

func (r orderToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r orderToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToUserFindMany) with()          {}
func (r orderToUserFindMany) orderModel()    {}
func (r orderToUserFindMany) orderRelation() {}

func (r orderToUserFindMany) With(params ...UserRelationWith) orderToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderToUserFindMany) Select(params ...orderPrismaFields) orderToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToUserFindMany) Omit(params ...orderPrismaFields) orderToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToUserFindMany) OrderBy(params ...UserOrderByParam) orderToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orderToUserFindMany) Skip(count int) orderToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orderToUserFindMany) Take(count int) orderToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orderToUserFindMany) Cursor(cursor OrderCursorParam) orderToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orderToUserFindMany) Exec(ctx context.Context) (
	[]OrderModel,
	error,
) {
	var v []OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orderToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerOrder,
	error,
) {
	var v []InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orderToUserFindMany) Update(params ...OrderSetParam) orderToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Order"

	r.query.Outputs = countOutput

	var v orderToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orderToUserUpdateMany struct {
	query builder.Query
}

func (r orderToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToUserUpdateMany) orderModel() {}

func (r orderToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToUserUpdateMany) Tx() OrderManyTxResult {
	v := newOrderManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orderToUserFindMany) Delete() orderToUserDeleteMany {
	var v orderToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Order"

	v.query.Outputs = countOutput

	return v
}

type orderToUserDeleteMany struct {
	query builder.Query
}

func (r orderToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orderToUserDeleteMany) orderModel() {}

func (r orderToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToUserDeleteMany) Tx() OrderManyTxResult {
	v := newOrderManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orderToProductFindUnique struct {
	query builder.Query
}

func (r orderToProductFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orderToProductFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToProductFindUnique) with()          {}
func (r orderToProductFindUnique) orderModel()    {}
func (r orderToProductFindUnique) orderRelation() {}

func (r orderToProductFindUnique) With(params ...ProductRelationWith) orderToProductFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderToProductFindUnique) Select(params ...orderPrismaFields) orderToProductFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToProductFindUnique) Omit(params ...orderPrismaFields) orderToProductFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToProductFindUnique) Exec(ctx context.Context) (
	*OrderModel,
	error,
) {
	var v *OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderToProductFindUnique) ExecInner(ctx context.Context) (
	*InnerOrder,
	error,
) {
	var v *InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderToProductFindUnique) Update(params ...OrderSetParam) orderToProductUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Order"

	var v orderToProductUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orderToProductUpdateUnique struct {
	query builder.Query
}

func (r orderToProductUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToProductUpdateUnique) orderModel() {}

func (r orderToProductUpdateUnique) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToProductUpdateUnique) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orderToProductFindUnique) Delete() orderToProductDeleteUnique {
	var v orderToProductDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Order"

	return v
}

type orderToProductDeleteUnique struct {
	query builder.Query
}

func (r orderToProductDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orderToProductDeleteUnique) orderModel() {}

func (r orderToProductDeleteUnique) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToProductDeleteUnique) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orderToProductFindFirst struct {
	query builder.Query
}

func (r orderToProductFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orderToProductFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToProductFindFirst) with()          {}
func (r orderToProductFindFirst) orderModel()    {}
func (r orderToProductFindFirst) orderRelation() {}

func (r orderToProductFindFirst) With(params ...ProductRelationWith) orderToProductFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderToProductFindFirst) Select(params ...orderPrismaFields) orderToProductFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToProductFindFirst) Omit(params ...orderPrismaFields) orderToProductFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToProductFindFirst) OrderBy(params ...ProductOrderByParam) orderToProductFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orderToProductFindFirst) Skip(count int) orderToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orderToProductFindFirst) Take(count int) orderToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orderToProductFindFirst) Cursor(cursor OrderCursorParam) orderToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orderToProductFindFirst) Exec(ctx context.Context) (
	*OrderModel,
	error,
) {
	var v *OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderToProductFindFirst) ExecInner(ctx context.Context) (
	*InnerOrder,
	error,
) {
	var v *InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orderToProductFindMany struct {
	query builder.Query
}

func (r orderToProductFindMany) getQuery() builder.Query {
	return r.query
}

func (r orderToProductFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToProductFindMany) with()          {}
func (r orderToProductFindMany) orderModel()    {}
func (r orderToProductFindMany) orderRelation() {}

func (r orderToProductFindMany) With(params ...ProductRelationWith) orderToProductFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderToProductFindMany) Select(params ...orderPrismaFields) orderToProductFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToProductFindMany) Omit(params ...orderPrismaFields) orderToProductFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderToProductFindMany) OrderBy(params ...ProductOrderByParam) orderToProductFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orderToProductFindMany) Skip(count int) orderToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orderToProductFindMany) Take(count int) orderToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orderToProductFindMany) Cursor(cursor OrderCursorParam) orderToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orderToProductFindMany) Exec(ctx context.Context) (
	[]OrderModel,
	error,
) {
	var v []OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orderToProductFindMany) ExecInner(ctx context.Context) (
	[]InnerOrder,
	error,
) {
	var v []InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orderToProductFindMany) Update(params ...OrderSetParam) orderToProductUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Order"

	r.query.Outputs = countOutput

	var v orderToProductUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orderToProductUpdateMany struct {
	query builder.Query
}

func (r orderToProductUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orderToProductUpdateMany) orderModel() {}

func (r orderToProductUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToProductUpdateMany) Tx() OrderManyTxResult {
	v := newOrderManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orderToProductFindMany) Delete() orderToProductDeleteMany {
	var v orderToProductDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Order"

	v.query.Outputs = countOutput

	return v
}

type orderToProductDeleteMany struct {
	query builder.Query
}

func (r orderToProductDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orderToProductDeleteMany) orderModel() {}

func (r orderToProductDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderToProductDeleteMany) Tx() OrderManyTxResult {
	v := newOrderManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orderFindUnique struct {
	query builder.Query
}

func (r orderFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orderFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orderFindUnique) with()          {}
func (r orderFindUnique) orderModel()    {}
func (r orderFindUnique) orderRelation() {}

func (r orderActions) FindUnique(
	params OrderEqualsUniqueWhereParam,
) orderFindUnique {
	var v orderFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Order"
	v.query.Outputs = orderOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orderFindUnique) With(params ...OrderRelationWith) orderFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderFindUnique) Select(params ...orderPrismaFields) orderFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderFindUnique) Omit(params ...orderPrismaFields) orderFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderFindUnique) Exec(ctx context.Context) (
	*OrderModel,
	error,
) {
	var v *OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderFindUnique) ExecInner(ctx context.Context) (
	*InnerOrder,
	error,
) {
	var v *InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderFindUnique) Update(params ...OrderSetParam) orderUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Order"

	var v orderUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orderUpdateUnique struct {
	query builder.Query
}

func (r orderUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orderUpdateUnique) orderModel() {}

func (r orderUpdateUnique) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderUpdateUnique) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orderFindUnique) Delete() orderDeleteUnique {
	var v orderDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Order"

	return v
}

type orderDeleteUnique struct {
	query builder.Query
}

func (r orderDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orderDeleteUnique) orderModel() {}

func (r orderDeleteUnique) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderDeleteUnique) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orderFindFirst struct {
	query builder.Query
}

func (r orderFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orderFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orderFindFirst) with()          {}
func (r orderFindFirst) orderModel()    {}
func (r orderFindFirst) orderRelation() {}

func (r orderActions) FindFirst(
	params ...OrderWhereParam,
) orderFindFirst {
	var v orderFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Order"
	v.query.Outputs = orderOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orderFindFirst) With(params ...OrderRelationWith) orderFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderFindFirst) Select(params ...orderPrismaFields) orderFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderFindFirst) Omit(params ...orderPrismaFields) orderFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderFindFirst) OrderBy(params ...OrderOrderByParam) orderFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orderFindFirst) Skip(count int) orderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orderFindFirst) Take(count int) orderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orderFindFirst) Cursor(cursor OrderCursorParam) orderFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orderFindFirst) Exec(ctx context.Context) (
	*OrderModel,
	error,
) {
	var v *OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orderFindFirst) ExecInner(ctx context.Context) (
	*InnerOrder,
	error,
) {
	var v *InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orderFindMany struct {
	query builder.Query
}

func (r orderFindMany) getQuery() builder.Query {
	return r.query
}

func (r orderFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orderFindMany) with()          {}
func (r orderFindMany) orderModel()    {}
func (r orderFindMany) orderRelation() {}

func (r orderActions) FindMany(
	params ...OrderWhereParam,
) orderFindMany {
	var v orderFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Order"
	v.query.Outputs = orderOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orderFindMany) With(params ...OrderRelationWith) orderFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orderFindMany) Select(params ...orderPrismaFields) orderFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orderFindMany) Omit(params ...orderPrismaFields) orderFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orderOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orderFindMany) OrderBy(params ...OrderOrderByParam) orderFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orderFindMany) Skip(count int) orderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orderFindMany) Take(count int) orderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orderFindMany) Cursor(cursor OrderCursorParam) orderFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orderFindMany) Exec(ctx context.Context) (
	[]OrderModel,
	error,
) {
	var v []OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orderFindMany) ExecInner(ctx context.Context) (
	[]InnerOrder,
	error,
) {
	var v []InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orderFindMany) Update(params ...OrderSetParam) orderUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Order"

	r.query.Outputs = countOutput

	var v orderUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orderUpdateMany struct {
	query builder.Query
}

func (r orderUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orderUpdateMany) orderModel() {}

func (r orderUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderUpdateMany) Tx() OrderManyTxResult {
	v := newOrderManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orderFindMany) Delete() orderDeleteMany {
	var v orderDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Order"

	v.query.Outputs = countOutput

	return v
}

type orderDeleteMany struct {
	query builder.Query
}

func (r orderDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orderDeleteMany) orderModel() {}

func (r orderDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderDeleteMany) Tx() OrderManyTxResult {
	v := newOrderManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type wishlistToUserFindUnique struct {
	query builder.Query
}

func (r wishlistToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r wishlistToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToUserFindUnique) with()             {}
func (r wishlistToUserFindUnique) wishlistModel()    {}
func (r wishlistToUserFindUnique) wishlistRelation() {}

func (r wishlistToUserFindUnique) With(params ...UserRelationWith) wishlistToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistToUserFindUnique) Select(params ...wishlistPrismaFields) wishlistToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToUserFindUnique) Omit(params ...wishlistPrismaFields) wishlistToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToUserFindUnique) Exec(ctx context.Context) (
	*WishlistModel,
	error,
) {
	var v *WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerWishlist,
	error,
) {
	var v *InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistToUserFindUnique) Update(params ...WishlistSetParam) wishlistToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Wishlist"

	var v wishlistToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type wishlistToUserUpdateUnique struct {
	query builder.Query
}

func (r wishlistToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToUserUpdateUnique) wishlistModel() {}

func (r wishlistToUserUpdateUnique) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToUserUpdateUnique) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r wishlistToUserFindUnique) Delete() wishlistToUserDeleteUnique {
	var v wishlistToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Wishlist"

	return v
}

type wishlistToUserDeleteUnique struct {
	query builder.Query
}

func (r wishlistToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p wishlistToUserDeleteUnique) wishlistModel() {}

func (r wishlistToUserDeleteUnique) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToUserDeleteUnique) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type wishlistToUserFindFirst struct {
	query builder.Query
}

func (r wishlistToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r wishlistToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToUserFindFirst) with()             {}
func (r wishlistToUserFindFirst) wishlistModel()    {}
func (r wishlistToUserFindFirst) wishlistRelation() {}

func (r wishlistToUserFindFirst) With(params ...UserRelationWith) wishlistToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistToUserFindFirst) Select(params ...wishlistPrismaFields) wishlistToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToUserFindFirst) Omit(params ...wishlistPrismaFields) wishlistToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToUserFindFirst) OrderBy(params ...UserOrderByParam) wishlistToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r wishlistToUserFindFirst) Skip(count int) wishlistToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r wishlistToUserFindFirst) Take(count int) wishlistToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r wishlistToUserFindFirst) Cursor(cursor WishlistCursorParam) wishlistToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r wishlistToUserFindFirst) Exec(ctx context.Context) (
	*WishlistModel,
	error,
) {
	var v *WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerWishlist,
	error,
) {
	var v *InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type wishlistToUserFindMany struct {
	query builder.Query
}

func (r wishlistToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r wishlistToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToUserFindMany) with()             {}
func (r wishlistToUserFindMany) wishlistModel()    {}
func (r wishlistToUserFindMany) wishlistRelation() {}

func (r wishlistToUserFindMany) With(params ...UserRelationWith) wishlistToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistToUserFindMany) Select(params ...wishlistPrismaFields) wishlistToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToUserFindMany) Omit(params ...wishlistPrismaFields) wishlistToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToUserFindMany) OrderBy(params ...UserOrderByParam) wishlistToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r wishlistToUserFindMany) Skip(count int) wishlistToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r wishlistToUserFindMany) Take(count int) wishlistToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r wishlistToUserFindMany) Cursor(cursor WishlistCursorParam) wishlistToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r wishlistToUserFindMany) Exec(ctx context.Context) (
	[]WishlistModel,
	error,
) {
	var v []WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r wishlistToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerWishlist,
	error,
) {
	var v []InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r wishlistToUserFindMany) Update(params ...WishlistSetParam) wishlistToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Wishlist"

	r.query.Outputs = countOutput

	var v wishlistToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type wishlistToUserUpdateMany struct {
	query builder.Query
}

func (r wishlistToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToUserUpdateMany) wishlistModel() {}

func (r wishlistToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToUserUpdateMany) Tx() WishlistManyTxResult {
	v := newWishlistManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r wishlistToUserFindMany) Delete() wishlistToUserDeleteMany {
	var v wishlistToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Wishlist"

	v.query.Outputs = countOutput

	return v
}

type wishlistToUserDeleteMany struct {
	query builder.Query
}

func (r wishlistToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p wishlistToUserDeleteMany) wishlistModel() {}

func (r wishlistToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToUserDeleteMany) Tx() WishlistManyTxResult {
	v := newWishlistManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type wishlistToProductFindUnique struct {
	query builder.Query
}

func (r wishlistToProductFindUnique) getQuery() builder.Query {
	return r.query
}

func (r wishlistToProductFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToProductFindUnique) with()             {}
func (r wishlistToProductFindUnique) wishlistModel()    {}
func (r wishlistToProductFindUnique) wishlistRelation() {}

func (r wishlistToProductFindUnique) With(params ...ProductRelationWith) wishlistToProductFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistToProductFindUnique) Select(params ...wishlistPrismaFields) wishlistToProductFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToProductFindUnique) Omit(params ...wishlistPrismaFields) wishlistToProductFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToProductFindUnique) Exec(ctx context.Context) (
	*WishlistModel,
	error,
) {
	var v *WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistToProductFindUnique) ExecInner(ctx context.Context) (
	*InnerWishlist,
	error,
) {
	var v *InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistToProductFindUnique) Update(params ...WishlistSetParam) wishlistToProductUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Wishlist"

	var v wishlistToProductUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type wishlistToProductUpdateUnique struct {
	query builder.Query
}

func (r wishlistToProductUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToProductUpdateUnique) wishlistModel() {}

func (r wishlistToProductUpdateUnique) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToProductUpdateUnique) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r wishlistToProductFindUnique) Delete() wishlistToProductDeleteUnique {
	var v wishlistToProductDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Wishlist"

	return v
}

type wishlistToProductDeleteUnique struct {
	query builder.Query
}

func (r wishlistToProductDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p wishlistToProductDeleteUnique) wishlistModel() {}

func (r wishlistToProductDeleteUnique) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToProductDeleteUnique) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type wishlistToProductFindFirst struct {
	query builder.Query
}

func (r wishlistToProductFindFirst) getQuery() builder.Query {
	return r.query
}

func (r wishlistToProductFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToProductFindFirst) with()             {}
func (r wishlistToProductFindFirst) wishlistModel()    {}
func (r wishlistToProductFindFirst) wishlistRelation() {}

func (r wishlistToProductFindFirst) With(params ...ProductRelationWith) wishlistToProductFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistToProductFindFirst) Select(params ...wishlistPrismaFields) wishlistToProductFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToProductFindFirst) Omit(params ...wishlistPrismaFields) wishlistToProductFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToProductFindFirst) OrderBy(params ...ProductOrderByParam) wishlistToProductFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r wishlistToProductFindFirst) Skip(count int) wishlistToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r wishlistToProductFindFirst) Take(count int) wishlistToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r wishlistToProductFindFirst) Cursor(cursor WishlistCursorParam) wishlistToProductFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r wishlistToProductFindFirst) Exec(ctx context.Context) (
	*WishlistModel,
	error,
) {
	var v *WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistToProductFindFirst) ExecInner(ctx context.Context) (
	*InnerWishlist,
	error,
) {
	var v *InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type wishlistToProductFindMany struct {
	query builder.Query
}

func (r wishlistToProductFindMany) getQuery() builder.Query {
	return r.query
}

func (r wishlistToProductFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToProductFindMany) with()             {}
func (r wishlistToProductFindMany) wishlistModel()    {}
func (r wishlistToProductFindMany) wishlistRelation() {}

func (r wishlistToProductFindMany) With(params ...ProductRelationWith) wishlistToProductFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistToProductFindMany) Select(params ...wishlistPrismaFields) wishlistToProductFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToProductFindMany) Omit(params ...wishlistPrismaFields) wishlistToProductFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistToProductFindMany) OrderBy(params ...ProductOrderByParam) wishlistToProductFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r wishlistToProductFindMany) Skip(count int) wishlistToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r wishlistToProductFindMany) Take(count int) wishlistToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r wishlistToProductFindMany) Cursor(cursor WishlistCursorParam) wishlistToProductFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r wishlistToProductFindMany) Exec(ctx context.Context) (
	[]WishlistModel,
	error,
) {
	var v []WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r wishlistToProductFindMany) ExecInner(ctx context.Context) (
	[]InnerWishlist,
	error,
) {
	var v []InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r wishlistToProductFindMany) Update(params ...WishlistSetParam) wishlistToProductUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Wishlist"

	r.query.Outputs = countOutput

	var v wishlistToProductUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type wishlistToProductUpdateMany struct {
	query builder.Query
}

func (r wishlistToProductUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistToProductUpdateMany) wishlistModel() {}

func (r wishlistToProductUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToProductUpdateMany) Tx() WishlistManyTxResult {
	v := newWishlistManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r wishlistToProductFindMany) Delete() wishlistToProductDeleteMany {
	var v wishlistToProductDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Wishlist"

	v.query.Outputs = countOutput

	return v
}

type wishlistToProductDeleteMany struct {
	query builder.Query
}

func (r wishlistToProductDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p wishlistToProductDeleteMany) wishlistModel() {}

func (r wishlistToProductDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistToProductDeleteMany) Tx() WishlistManyTxResult {
	v := newWishlistManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type wishlistFindUnique struct {
	query builder.Query
}

func (r wishlistFindUnique) getQuery() builder.Query {
	return r.query
}

func (r wishlistFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistFindUnique) with()             {}
func (r wishlistFindUnique) wishlistModel()    {}
func (r wishlistFindUnique) wishlistRelation() {}

func (r wishlistActions) FindUnique(
	params WishlistEqualsUniqueWhereParam,
) wishlistFindUnique {
	var v wishlistFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Wishlist"
	v.query.Outputs = wishlistOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r wishlistFindUnique) With(params ...WishlistRelationWith) wishlistFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistFindUnique) Select(params ...wishlistPrismaFields) wishlistFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistFindUnique) Omit(params ...wishlistPrismaFields) wishlistFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistFindUnique) Exec(ctx context.Context) (
	*WishlistModel,
	error,
) {
	var v *WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistFindUnique) ExecInner(ctx context.Context) (
	*InnerWishlist,
	error,
) {
	var v *InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistFindUnique) Update(params ...WishlistSetParam) wishlistUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Wishlist"

	var v wishlistUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type wishlistUpdateUnique struct {
	query builder.Query
}

func (r wishlistUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistUpdateUnique) wishlistModel() {}

func (r wishlistUpdateUnique) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistUpdateUnique) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r wishlistFindUnique) Delete() wishlistDeleteUnique {
	var v wishlistDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Wishlist"

	return v
}

type wishlistDeleteUnique struct {
	query builder.Query
}

func (r wishlistDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p wishlistDeleteUnique) wishlistModel() {}

func (r wishlistDeleteUnique) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistDeleteUnique) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type wishlistFindFirst struct {
	query builder.Query
}

func (r wishlistFindFirst) getQuery() builder.Query {
	return r.query
}

func (r wishlistFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistFindFirst) with()             {}
func (r wishlistFindFirst) wishlistModel()    {}
func (r wishlistFindFirst) wishlistRelation() {}

func (r wishlistActions) FindFirst(
	params ...WishlistWhereParam,
) wishlistFindFirst {
	var v wishlistFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Wishlist"
	v.query.Outputs = wishlistOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r wishlistFindFirst) With(params ...WishlistRelationWith) wishlistFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistFindFirst) Select(params ...wishlistPrismaFields) wishlistFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistFindFirst) Omit(params ...wishlistPrismaFields) wishlistFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistFindFirst) OrderBy(params ...WishlistOrderByParam) wishlistFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r wishlistFindFirst) Skip(count int) wishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r wishlistFindFirst) Take(count int) wishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r wishlistFindFirst) Cursor(cursor WishlistCursorParam) wishlistFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r wishlistFindFirst) Exec(ctx context.Context) (
	*WishlistModel,
	error,
) {
	var v *WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r wishlistFindFirst) ExecInner(ctx context.Context) (
	*InnerWishlist,
	error,
) {
	var v *InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type wishlistFindMany struct {
	query builder.Query
}

func (r wishlistFindMany) getQuery() builder.Query {
	return r.query
}

func (r wishlistFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistFindMany) with()             {}
func (r wishlistFindMany) wishlistModel()    {}
func (r wishlistFindMany) wishlistRelation() {}

func (r wishlistActions) FindMany(
	params ...WishlistWhereParam,
) wishlistFindMany {
	var v wishlistFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Wishlist"
	v.query.Outputs = wishlistOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r wishlistFindMany) With(params ...WishlistRelationWith) wishlistFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r wishlistFindMany) Select(params ...wishlistPrismaFields) wishlistFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistFindMany) Omit(params ...wishlistPrismaFields) wishlistFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range wishlistOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r wishlistFindMany) OrderBy(params ...WishlistOrderByParam) wishlistFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r wishlistFindMany) Skip(count int) wishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r wishlistFindMany) Take(count int) wishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r wishlistFindMany) Cursor(cursor WishlistCursorParam) wishlistFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r wishlistFindMany) Exec(ctx context.Context) (
	[]WishlistModel,
	error,
) {
	var v []WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r wishlistFindMany) ExecInner(ctx context.Context) (
	[]InnerWishlist,
	error,
) {
	var v []InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r wishlistFindMany) Update(params ...WishlistSetParam) wishlistUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Wishlist"

	r.query.Outputs = countOutput

	var v wishlistUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type wishlistUpdateMany struct {
	query builder.Query
}

func (r wishlistUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistUpdateMany) wishlistModel() {}

func (r wishlistUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistUpdateMany) Tx() WishlistManyTxResult {
	v := newWishlistManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r wishlistFindMany) Delete() wishlistDeleteMany {
	var v wishlistDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Wishlist"

	v.query.Outputs = countOutput

	return v
}

type wishlistDeleteMany struct {
	query builder.Query
}

func (r wishlistDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p wishlistDeleteMany) wishlistModel() {}

func (r wishlistDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistDeleteMany) Tx() WishlistManyTxResult {
	v := newWishlistManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newUserUniqueTxResult() UserUniqueTxResult {
	return UserUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserUniqueTxResult) IsTx() {}

func (r UserUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserManyTxResult() UserManyTxResult {
	return UserManyTxResult{
		result: &transaction.Result{},
	}
}

type UserManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserManyTxResult) IsTx() {}

func (r UserManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newVendorUniqueTxResult() VendorUniqueTxResult {
	return VendorUniqueTxResult{
		result: &transaction.Result{},
	}
}

type VendorUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p VendorUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p VendorUniqueTxResult) IsTx() {}

func (r VendorUniqueTxResult) Result() (v *VendorModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newVendorManyTxResult() VendorManyTxResult {
	return VendorManyTxResult{
		result: &transaction.Result{},
	}
}

type VendorManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p VendorManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p VendorManyTxResult) IsTx() {}

func (r VendorManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newProductUniqueTxResult() ProductUniqueTxResult {
	return ProductUniqueTxResult{
		result: &transaction.Result{},
	}
}

type ProductUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ProductUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ProductUniqueTxResult) IsTx() {}

func (r ProductUniqueTxResult) Result() (v *ProductModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newProductManyTxResult() ProductManyTxResult {
	return ProductManyTxResult{
		result: &transaction.Result{},
	}
}

type ProductManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ProductManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ProductManyTxResult) IsTx() {}

func (r ProductManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrderUniqueTxResult() OrderUniqueTxResult {
	return OrderUniqueTxResult{
		result: &transaction.Result{},
	}
}

type OrderUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrderUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrderUniqueTxResult) IsTx() {}

func (r OrderUniqueTxResult) Result() (v *OrderModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrderManyTxResult() OrderManyTxResult {
	return OrderManyTxResult{
		result: &transaction.Result{},
	}
}

type OrderManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrderManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrderManyTxResult) IsTx() {}

func (r OrderManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWishlistUniqueTxResult() WishlistUniqueTxResult {
	return WishlistUniqueTxResult{
		result: &transaction.Result{},
	}
}

type WishlistUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WishlistUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WishlistUniqueTxResult) IsTx() {}

func (r WishlistUniqueTxResult) Result() (v *WishlistModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWishlistManyTxResult() WishlistManyTxResult {
	return WishlistManyTxResult{
		result: &transaction.Result{},
	}
}

type WishlistManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WishlistManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WishlistManyTxResult) IsTx() {}

func (r WishlistManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_firstName UserWithPrismaFirstNameSetParam,
	_otherName UserWithPrismaOtherNameSetParam,
	_email UserWithPrismaEmailSetParam,
	_password UserWithPrismaPasswordSetParam,
	_salt UserWithPrismaSaltSetParam,
	_role UserWithPrismaRoleSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _firstName.field())
	fields = append(fields, _otherName.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())
	fields = append(fields, _salt.field())
	fields = append(fields, _role.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) CreateOrUpdate(

	_firstName UserWithPrismaFirstNameSetParam,
	_otherName UserWithPrismaOtherNameSetParam,
	_email UserWithPrismaEmailSetParam,
	_password UserWithPrismaPasswordSetParam,
	_salt UserWithPrismaSaltSetParam,
	_role UserWithPrismaRoleSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _firstName.field())
	fields = append(fields, _otherName.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())
	fields = append(fields, _salt.field())
	fields = append(fields, _role.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type vendorUpsertOne struct {
	query builder.Query
}

func (r vendorUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r vendorUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorUpsertOne) with()           {}
func (r vendorUpsertOne) vendorModel()    {}
func (r vendorUpsertOne) vendorRelation() {}

func (r vendorActions) UpsertOne(
	params VendorEqualsUniqueWhereParam,
) vendorUpsertOne {
	var v vendorUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Vendor"
	v.query.Outputs = vendorOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r vendorUpsertOne) Create(

	_user VendorWithPrismaUserSetParam,
	_businessName VendorWithPrismaBusinessNameSetParam,
	_taxPin VendorWithPrismaTaxPinSetParam,

	optional ...VendorSetParam,
) vendorUpsertOne {
	var v vendorUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _businessName.field())
	fields = append(fields, _taxPin.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r vendorUpsertOne) Update(
	params ...VendorSetParam,
) vendorUpsertOne {
	var v vendorUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r vendorUpsertOne) CreateOrUpdate(

	_user VendorWithPrismaUserSetParam,
	_businessName VendorWithPrismaBusinessNameSetParam,
	_taxPin VendorWithPrismaTaxPinSetParam,

	optional ...VendorSetParam,
) vendorUpsertOne {
	var v vendorUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _businessName.field())
	fields = append(fields, _taxPin.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r vendorUpsertOne) Exec(ctx context.Context) (*VendorModel, error) {
	var v VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r vendorUpsertOne) Tx() VendorUniqueTxResult {
	v := newVendorUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productUpsertOne struct {
	query builder.Query
}

func (r productUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r productUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r productUpsertOne) with()            {}
func (r productUpsertOne) productModel()    {}
func (r productUpsertOne) productRelation() {}

func (r productActions) UpsertOne(
	params ProductEqualsUniqueWhereParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Product"
	v.query.Outputs = productOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r productUpsertOne) Create(

	_vendor ProductWithPrismaVendorSetParam,
	_name ProductWithPrismaNameSetParam,
	_price ProductWithPrismaPriceSetParam,
	_category ProductWithPrismaCategorySetParam,
	_imageURL ProductWithPrismaImageURLSetParam,

	optional ...ProductSetParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _vendor.field())
	fields = append(fields, _name.field())
	fields = append(fields, _price.field())
	fields = append(fields, _category.field())
	fields = append(fields, _imageURL.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r productUpsertOne) Update(
	params ...ProductSetParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r productUpsertOne) CreateOrUpdate(

	_vendor ProductWithPrismaVendorSetParam,
	_name ProductWithPrismaNameSetParam,
	_price ProductWithPrismaPriceSetParam,
	_category ProductWithPrismaCategorySetParam,
	_imageURL ProductWithPrismaImageURLSetParam,

	optional ...ProductSetParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _vendor.field())
	fields = append(fields, _name.field())
	fields = append(fields, _price.field())
	fields = append(fields, _category.field())
	fields = append(fields, _imageURL.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r productUpsertOne) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productUpsertOne) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orderUpsertOne struct {
	query builder.Query
}

func (r orderUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r orderUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r orderUpsertOne) with()          {}
func (r orderUpsertOne) orderModel()    {}
func (r orderUpsertOne) orderRelation() {}

func (r orderActions) UpsertOne(
	params OrderEqualsUniqueWhereParam,
) orderUpsertOne {
	var v orderUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Order"
	v.query.Outputs = orderOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orderUpsertOne) Create(

	_user OrderWithPrismaUserSetParam,
	_product OrderWithPrismaProductSetParam,
	_quantity OrderWithPrismaQuantitySetParam,
	_status OrderWithPrismaStatusSetParam,

	optional ...OrderSetParam,
) orderUpsertOne {
	var v orderUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _product.field())
	fields = append(fields, _quantity.field())
	fields = append(fields, _status.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r orderUpsertOne) Update(
	params ...OrderSetParam,
) orderUpsertOne {
	var v orderUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r orderUpsertOne) CreateOrUpdate(

	_user OrderWithPrismaUserSetParam,
	_product OrderWithPrismaProductSetParam,
	_quantity OrderWithPrismaQuantitySetParam,
	_status OrderWithPrismaStatusSetParam,

	optional ...OrderSetParam,
) orderUpsertOne {
	var v orderUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _product.field())
	fields = append(fields, _quantity.field())
	fields = append(fields, _status.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r orderUpsertOne) Exec(ctx context.Context) (*OrderModel, error) {
	var v OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orderUpsertOne) Tx() OrderUniqueTxResult {
	v := newOrderUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type wishlistUpsertOne struct {
	query builder.Query
}

func (r wishlistUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r wishlistUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistUpsertOne) with()             {}
func (r wishlistUpsertOne) wishlistModel()    {}
func (r wishlistUpsertOne) wishlistRelation() {}

func (r wishlistActions) UpsertOne(
	params WishlistEqualsUniqueWhereParam,
) wishlistUpsertOne {
	var v wishlistUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Wishlist"
	v.query.Outputs = wishlistOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r wishlistUpsertOne) Create(

	_user WishlistWithPrismaUserSetParam,
	_product WishlistWithPrismaProductSetParam,

	optional ...WishlistSetParam,
) wishlistUpsertOne {
	var v wishlistUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _product.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r wishlistUpsertOne) Update(
	params ...WishlistSetParam,
) wishlistUpsertOne {
	var v wishlistUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r wishlistUpsertOne) CreateOrUpdate(

	_user WishlistWithPrismaUserSetParam,
	_product WishlistWithPrismaProductSetParam,

	optional ...WishlistSetParam,
) wishlistUpsertOne {
	var v wishlistUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _product.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r wishlistUpsertOne) Exec(ctx context.Context) (*WishlistModel, error) {
	var v WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r wishlistUpsertOne) Tx() WishlistUniqueTxResult {
	v := newWishlistUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template raw.gotpl ---

type userAggregateRaw struct {
	query builder.Query
}

func (r userAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r userAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r userAggregateRaw) with()         {}
func (r userAggregateRaw) userModel()    {}
func (r userAggregateRaw) userRelation() {}

func (r userActions) FindRaw(filter interface{}, options ...interface{}) userAggregateRaw {
	var v userAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "User"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userActions) AggregateRaw(pipeline []interface{}, options ...interface{}) userAggregateRaw {
	var v userAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "User"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userAggregateRaw) Exec(ctx context.Context) ([]UserModel, error) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r userAggregateRaw) ExecInner(ctx context.Context) ([]InnerUser, error) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type vendorAggregateRaw struct {
	query builder.Query
}

func (r vendorAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r vendorAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r vendorAggregateRaw) with()           {}
func (r vendorAggregateRaw) vendorModel()    {}
func (r vendorAggregateRaw) vendorRelation() {}

func (r vendorActions) FindRaw(filter interface{}, options ...interface{}) vendorAggregateRaw {
	var v vendorAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Vendor"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r vendorActions) AggregateRaw(pipeline []interface{}, options ...interface{}) vendorAggregateRaw {
	var v vendorAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Vendor"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r vendorAggregateRaw) Exec(ctx context.Context) ([]VendorModel, error) {
	var v []VendorModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r vendorAggregateRaw) ExecInner(ctx context.Context) ([]InnerVendor, error) {
	var v []InnerVendor
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type productAggregateRaw struct {
	query builder.Query
}

func (r productAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r productAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r productAggregateRaw) with()            {}
func (r productAggregateRaw) productModel()    {}
func (r productAggregateRaw) productRelation() {}

func (r productActions) FindRaw(filter interface{}, options ...interface{}) productAggregateRaw {
	var v productAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Product"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r productActions) AggregateRaw(pipeline []interface{}, options ...interface{}) productAggregateRaw {
	var v productAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Product"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r productAggregateRaw) Exec(ctx context.Context) ([]ProductModel, error) {
	var v []ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r productAggregateRaw) ExecInner(ctx context.Context) ([]InnerProduct, error) {
	var v []InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type orderAggregateRaw struct {
	query builder.Query
}

func (r orderAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r orderAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r orderAggregateRaw) with()          {}
func (r orderAggregateRaw) orderModel()    {}
func (r orderAggregateRaw) orderRelation() {}

func (r orderActions) FindRaw(filter interface{}, options ...interface{}) orderAggregateRaw {
	var v orderAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Order"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orderActions) AggregateRaw(pipeline []interface{}, options ...interface{}) orderAggregateRaw {
	var v orderAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Order"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orderAggregateRaw) Exec(ctx context.Context) ([]OrderModel, error) {
	var v []OrderModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r orderAggregateRaw) ExecInner(ctx context.Context) ([]InnerOrder, error) {
	var v []InnerOrder
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type wishlistAggregateRaw struct {
	query builder.Query
}

func (r wishlistAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r wishlistAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r wishlistAggregateRaw) with()             {}
func (r wishlistAggregateRaw) wishlistModel()    {}
func (r wishlistAggregateRaw) wishlistRelation() {}

func (r wishlistActions) FindRaw(filter interface{}, options ...interface{}) wishlistAggregateRaw {
	var v wishlistAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Wishlist"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r wishlistActions) AggregateRaw(pipeline []interface{}, options ...interface{}) wishlistAggregateRaw {
	var v wishlistAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Wishlist"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r wishlistAggregateRaw) Exec(ctx context.Context) ([]WishlistModel, error) {
	var v []WishlistModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r wishlistAggregateRaw) ExecInner(ctx context.Context) ([]InnerWishlist, error) {
	var v []InnerWishlist
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}
